{"version":3,"sources":["webpack:///webpack/bootstrap dd3b6adb4c67567b528f","webpack:///./app/node_modules/codemirror/addon/runmode/runmode.node.js","webpack:///./app/node_modules/codemirror/mode/xml/xml.js","webpack:///./app/node_modules/codemirror/mode/javascript/javascript.js","webpack:///./app/node_modules/codemirror/mode/htmlmixed/htmlmixed.js","webpack:///./app/node_modules/codemirror/mode/css/css.js","webpack:///./app/node_modules/codemirror/mode/clike/clike.js","webpack:///./app/src/highlighter/index.ts","webpack:///./app/node_modules/codemirror/mode/jsx/jsx.js","webpack:///./app/node_modules/codemirror/mode/markdown/markdown.js","webpack:///./app/node_modules/codemirror/mode/meta.js","webpack:///./app/node_modules/codemirror/mode/yaml/yaml.js","webpack:///./app/node_modules/codemirror/mode/shell/shell.js","webpack:///./app/node_modules/codemirror/mode/go/go.js","webpack:///./app/node_modules/codemirror/mode/perl/perl.js","webpack:///./app/node_modules/codemirror/mode/php/php.js","webpack:///./app/node_modules/codemirror/mode/python/python.js","webpack:///./app/node_modules/codemirror/mode/ruby/ruby.js"],"names":[],"mappings":"YACA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,aAIA,mCAGA,aAGA,OACA,OAIA,OAzBA,YA4BA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,8BC1DA,CAEA,cAA4B,0BAG5B,CAgBA,iBACA,qBACA,OACA,yBACA,0CACA,iBACA,OACA,UAkGA,iBACA,QAEA,YADA,uCAEA,0BACA,MACA,QAGA,CAjIA,uCACA,CACA,qBACA,2BAEA,+BAAqD,IACrD,gBACA,aACA,eACA,QACA,SACA,QACA,CACA,GAWA,YACA,gBAAmB,mCACnB,iBAAmB,+BACnB,kBAAoB,2CACpB,iBACA,yBACA,sCACA,MACA,iBACA,+BACA,iCACA,qCACA,gBAAa,OACb,aACA,sBACA,gBACA,SACA,qBACA,KACA,qBACA,gBACA,4DACA,gBACA,KACA,uBAAyB,2BACzB,oBACA,kCACA,aACA,MADqB,MAAiB,QAEtC,qBAAuB,WACvB,mBACA,gCACA,2FACA,yCAEA,uFACA,EACA,wBACA,gCACA,oEACA,EACA,uBACA,uBACA,mBAAiC,0BACjC,kCACA,iBACA,KAGA,2BAFA,UAEK,KACL,mCACA,6BACA,iCAEA,UACA,CACA,qBAAsB,6CACtB,8BACA,MACA,gBAAS,OAAgB,IACzB,QAAa,MAAqB,YAClC,CACA,uBACA,oBACA,6DACA,QACA,GACA,iBAEA,4BACA,wBACA,iBAEA,cAA8B,oBAC9B,0BACA,CACA,yEACA,IACA,QACA,0BAA2C,CAAwB,QAEnE,8BACA,QAAU,kBAAyB,aACnC,EAAC,GACD,kCAEA,yBACA,6BACA,oBACG,oDACH,cAEA,2BACA,YAAuB,KACvB,SAYA,0BACA,0BACA,qCACA,GACA,QAEA,uBACA,SACA,qBACA,+BACA,oBACA,mCACA,WACA,aACA,UACA,mDACA,WAEA,KACA,aACA,mCACA,uCACA,iBAEA,aACA,UAEA,yBACA,QACA,KACA,gBACA,kBACA,cACA,UAEA,gBAAkB,OAClB,UAEA,iDAEA,2BACA,sBAA8B,WAC9B,6BACA,iBAAiB,aACjB,WAAmC,OAAO,iBAC1C,MACA,oCACA,mCACA,uBACA,SACA,+BACA,mBACA,GACA,CACA,GAEA,cACA,8BCnMA,CAEA,YAEA,KAKA,GAAC,eACD,aAEA,MACA,kBAAoB,6BACpB,0CACA,4CACA,0BACA,+BAAqB,kCACrB,gCACA,eACA,uBACA,KAAW,MACX,WAAW,MACX,WACA,eAAe,UACf,uBACA,gBAAU,6CACV,0CACA,sCACA,+CACA,sCACA,WAAW,MACX,WAAW,MACX,cAAc,SACd,cAAW,MACX,cACA,cAAW,MACX,cAAc,SACd,cAEA,qBACA,QACA,iBACA,gBAGA,eACA,iBACA,oBACA,mBACA,eACA,GACA,iBACA,gBACA,aAEA,gCACA,gBAUA,cACA,UACA,WACA,MAEA,SACA,UACA,oBACA,WACA,kCACA,QACS,aACT,oBACS,gBACT,6BACA,iBAEA,KAEO,WACP,iBACA,iCACA,MAEA,iCACA,YACA,WAEK,yBACL,IACA,kBACA,WACA,qCAEA,+BAGA,oCAEA,cACA,OACA,mBACA,SAEA,IACA,gBAGA,SACA,gCACA,cACA,6BACA,eACK,iBACL,gBACA,SACK,eACL,GACA,aACA,6BACA,aACA,sCACA,WAAK,iBACL,oBACA,wBACA,WAEA,wBACA,4CAEA,OAEA,cACA,oBACA,SACA,sBACA,GACA,WACA,KAEA,OACA,QACA,EAEA,SADA,kBAGA,gBACA,qBACA,gBACA,eACA,GACA,WACA,KACA,GACA,MACA,CACA,QACA,CACA,cACA,qBACA,QACA,GACA,wBACA,6BACA,KACS,iBACT,eACA,GACA,WACA,KACA,4BACA,KAIA,oBACA,MACA,CAEA,kBACA,aACA,aACA,wBACA,cACA,qEACA,iBACA,YACA,cACA,iCACA,KACA,gBACA,QACA,KACA,OACA,QAEA,sBACA,2BACA,yCACA,kBAEA,OACA,IACA,CAEA,kBACA,OACA,2BAEK,YAKL,iBACA,kBACA,OACA,uBACA,YAGA,YAGA,UACA,kBACA,cACA,SACA,sCACA,wDACA,UACA,6CACA,gBAGA,YAGA,cACA,CAGA,SAFA,SAIA,kBACA,OACA,aAKA,WAFA,UAGA,kBACA,UACA,QACA,QAEA,kBACA,IACA,UAEK,SADL,gDAEA,qBACA,SASA,4BARA,KACA,qCACA,kBAEA,QACA,gCAEA,YAEA,CAEA,SADA,SAEA,kBACA,OACA,kCACA,SACA,SACA,kBACA,OACA,0CAAiD,EACjD,eACA,QACA,SACA,kBACA,OACA,cACA,QAEA,SAjPA,aACA,OACA,iCACA,yBAGA,WAEA,WAgDA,YA0LA,uBACA,QACA,WACA,oBACA,wBACA,aACA,MAEA,mBADA,eAGA,qBACA,kBACA,qBAEA,kCACA,QACA,aACA,cAOA,cANA,iBACA,qBAEA,6BAEA,cAGA,wBACA,SAEA,sBACA,mCACA,0BAEA,IAEA,qCACA,yBACA,iDAEA,OACA,qBACA,oEAIA,+BAFA,+CAGA,kCACA,gBAEA,+BACA,KACA,KACA,KAAW,6CACX,aAEA,SAGO,YACP,cACA,2BACA,kCACA,QAEA,SACA,MAEA,oBACA,iBACA,gBACA,uBACA,CAEA,gBACA,kCACA,uBAEA,sCACA,mCAEA,+BACA,GACA,aACA,QAEA,EAAC,GAED,+BACA,+BACA,kCACA,wCAAsC,WAEtC,aAAC,mBCxYD,CAEA,YAEA,KAKA,GAAC,eACD,aAEA,uCACA,cA6DA,gBACA,yBACA,OACA,eACA,cACA,iBACA,KACA,OACA,OACA,CAIA,kBAEA,CAEA,MAFc,MACd,MAEA,gBACA,SACA,kBACA,0BACA,OACK,iCACL,4CACK,6BACL,wBACK,WAAwB,qBAC7B,cACK,uBACL,mBACK,6BACL,wBACA,uBACK,2BACL,wBACA,qBACK,2BACL,wBACA,oBACK,kBACL,uBACA,+CACK,aACL,oBACA,QACA,WACO,cACP,QACA,wBACO,mBACP,IACA,aACA,8CAEA,oBACA,+BAEK,eACL,gBACA,WACK,UACL,gBACA,sBACK,eACL,iCACA,4BACA,6BACS,gBACT,YACA,iBAGA,mCACK,yBACL,GACA,qBACA,6BACA,+BACA,OACA,wBACA,QACA,wBACA,kCACA,YACA,qBACA,aACA,CAEA,cACA,qBACA,IACA,gCACA,mBACA,8BAEA,aACA,qBACA,gBAEA,qBACA,uBACA,SACA,CAEA,gBACA,QACA,oBACA,cACA,GACA,WACA,KACA,GACA,MACA,oBACA,UAEA,gBACA,QACA,4BACA,+BAAkE,MAClE,GACA,WACA,KACA,OACA,OACA,+BACA,UAEA,gBASA,6BACA,oCACA,YAEA,YACA,OAAoD,mEACpD,kBACA,MAEA,aACA,SAA6B,EAAU,SACvC,gBACA,eACA,wBACA,OAAqB,CAAO,IAAO,KACnC,WAA2B,UAAoC,MAAO,KACtE,CAAO,eACP,IACO,eACP,QACO,sBACP,QACO,gBACP,CACA,IACA,KACA,EACA,WACA,cAIA,wBAGA,MACA,gBACA,cACA,YACA,YACA,sBACA,QAEA,gBACA,aAAoC,gBACpC,kBACA,qBAAoC,cACpC,iBAA8B,WAC9B,kBAEA,QAEA,sBACA,SAGA,UAAqB,WAAoB,2BAA8B,QAEvE,iCACA,qBAEA,YACA,wBACA,iBACA,8BACA,OACA,4BACA,6BAEA,cACA,CACA,CAIA,aAEA,4BAAsC,EAAQ,oBAC9C,aACA,aACA,CAEA,oBADA,aAEA,cACA,cACA,QAA2B,WAC3B,kBACA,SACA,QACA,UACA,mBACA,gBACA,mBACA,oBAAyB,cACzB,UAAK,KACL,oBACA,SACA,2BAA4B,cAC5B,YACA,CAIA,aAEA,mBAAwB,oCACxB,oBACA,YACA,aACA,qCACA,uCACA,IACA,gBACA,iBACA,oBACA,+CACA,0BAA0C,0BAA2C,UACrF,SACA,uDACA,UACA,EAEA,SADA,QAEA,aACA,UACA,gBACA,OACA,2CACA,8BAEA,KACA,cAGA,cACA,aACA,IAA2B,OAC3B,IACA,IACA,CACA,QAEA,gBACA,2CACA,2BACA,kCACA,4EACA,0BACA,MAAkB,WAClB,UAAkB,OAClB,IACA,uEACA,mBACA,YAEA,iCACA,mBACA,gBACA,kBACA,qBACA,gCACO,WACP,wBACA,UAEA,UAGA,uCAA2E,OAAc,IAEzF,iCACA,uBACA,2CAEA,2BACA,8BACA,8BACA,0CAAyE,OACzE,uBACA,YACA,uBACA,OACA,cACA,OACA,QACA,cACA,OACA,QACA,cACA,2BAEA,QADA,GAEA,gBACA,yCACA,OACA,gDACA,2CACA,UAEA,OACA,kCACA,mBACA,uBACA,2CACA,2BACA,uCACA,kBACA,aAAkB,WAAkC,IACpD,mBACA,kBACA,MACA,GACA,cACA,gBAAwB,cACxB,IACA,IAEA,gBACA,cACA,KACA,SACA,kBACA,OACA,YACA,4BACA,SACA,4CACA,kBACA,QAEA,KAA0B,WAC1B,OACA,6BACA,iBACA,2BACA,cAAgC,mBAAuB,UACvD,QACA,yCACA,0DACA,GAEA,YACA,gBACA,kBAC4C,0BAE5C,OADA,KADA,GAGA,cACA,IACA,wBACA,oBACA,WAEA,IACA,cACA,uBACA,SACA,WACA,cACA,uBACA,SACA,WACA,cACA,mBACA,gBACA,6BACA,SACA,MACA,CACA,gBACA,IAA4B,6BAAuB,UACnD,IACA,gBACA,IAA4B,6BAAuB,UACnD,IACA,cACA,cACA,aACA,OACA,cACA,wBAA6B,WAAuB,WACpD,GACA,gBACA,IACA,4BACA,WACK,2CACL,cACA,oCACA,SACA,uEACA,yDACA,QACA,IAAK,oBACL,8CACA,YACK,MACL,oBACK,KACL,cACK,KACL,aACK,QACL,YACK,OACL,kBACA,UACK,MACL,OAEA,WACA,cACA,gCAEA,WACA,OAFA,IAGA,cACA,cACA,YACA,YACA,kBACA,gBACA,6BACA,gBACA,gDACA,kBACA,mBACA,IACA,IACA,IACA,mBACA,MACA,KACA,qBACA,mBACA,IACA,MACA,CACA,kBACA,WAAmB,cAAsB,OACzC,eACA,8BACA,SACA,cACA,OAAkB,OAClB,IACA,MACA,gBACA,OACA,iBACA,sBACA,KACA,CACA,gBACA,sBACA,UACA,sBACA,UAEA,iBACA,OAGA,0CACA,6BACA,UAAkB,WAAyB,SAAyB,IACpE,wBACA,cACA,cACA,kBACA,KACA,gBACA,sBACA,+BACA,WACK,MACL,OACK,KACL,OACK,KACL,eAEA,cACA,cACA,qBACA,YACA,WACA,gBACA,2BACA,yBACA,gBACA,qBACA,WACA,gBACA,+BACA,SACA,aACA,OACA,aACA,gBACA,qBACA,KAA6B,eAAiB,KAC9C,iBACA,gBACA,KAAkB,WAClB,WACA,gBACA,sCACA,uCAIA,wBACA,KAAkB,OAClB,QACA,aANA,KAEA,MAKA,iBACA,iBACA,KACA,eACA,iBACA,KACA,iBACA,gDACA,YACA,eACA,gCACA,OACA,eACA,sBACA,SAAkB,OAClB,oBACA,YACA,QACA,iBACA,gBAAyC,mBAAuB,UAChE,MACA,OACA,iBACA,OAAkB,OAClB,eAAyC,mBAAuB,UAChE,YACA,QACA,eACA,SACA,IACA,iBACA,eAAuB,UAAsB,UAC7C,sBAA6C,KAC7C,8BACA,sCACA,iBACA,iBACA,eACA,mCACA,MACA,SACA,iBAEA,qBACA,QACA,OACA,iBACA,wBAA6C,MAC7C,KACA,iBACA,2BACA,8CACA,SACA,WAAkB,WAClB,iBACA,iBACA,sBACA,YACA,uCACA,2BACA,sCACA,UAEA,sBACA,+BACA,aAEA,cACA,kBACA,aACA,kBACA,UAEA,OAAkB,OAClB,MAAkB,OAClB,WACA,cACA,iBACA,cACA,aACA,eACA,KACA,KACA,iBACA,OAAuB,kBAAuB,iBAC9C,OAA6B,wBAAuB,gBACpD,OAAkB,cAAuC,UACzD,MACA,IACA,iBACA,OAAwB,mBAAuB,cAC/C,4BACA,cACA,eACA,mBACA,IACA,WACA,iBACA,OAAkB,YAClB,qBACA,wBACA,WACA,MACA,eACA,iBACA,SACA,iBACA,IAAwB,yBAAuB,UAC/C,KACA,iBACA,IAA0B,2BAAuB,UACjD,IACA,eACA,cACA,UACA,KAEA,iBACA,+BACA,kCACA,0BACA,GAEA,mBACA,UACA,aAA8E,wFAC9E,gCAAuC,yCACvC,IAIA,QA/pBA,QA1EA,gBACA,qBACA,YACA,cACA,gCAIA,gCACA,eAAuB,OAAQ,uBAC/B,4DACA,gCAA2C,kBAE3C,UACA,6CACA,mEACA,iEACA,sCACA,kEACA,yBACA,qDACA,mDACA,sDACA,UAIA,eACA,QAAkB,sBAClB,UAEA,aACA,SACA,aACA,qBACA,iBAGA,mBACA,sBACA,wBACA,uBACA,uBAGA,wCAGA,cACA,aAEA,IAEA,CACA,QAEA,OACA,uBAEA,2FA0IA,aAiCqB,0DAErB,yBAyCY,sCACZ,UA2BqB,kBAAqB,KAC1C,uBA6BA,OA+ZA,uBACA,OACA,CACA,oBACA,SACA,6BACA,wBACA,gCAA4C,OAC5C,uBAEA,GAGA,qBAFA,+CACA,aAGA,qBACA,MACA,kCACA,qBACA,uBACA,cAEA,0CACA,cACA,oBACA,iEACA,YACA,eAEA,sBACA,2BACA,4BACA,MAEA,iFAA0E,EAAQ,KAClF,WACA,eACA,mBAEA,4BACA,kBAA6B,4BAC7B,YACA,2BACA,cACA,sBACA,0BACA,qBAEA,oFACA,cAAgD,SAChD,qBACA,YACA,qCACA,8BACA,yCAEA,iBACA,mDAFA,KAIA,gBACA,8DACA,6BACA,kCACA,0BACA,UACA,sBAEA,sCACA,aACA,cAEA,YAEA,+CACA,wBACA,sBACA,KAEA,EAAC,GAED,mDAEA,6CACA,6CACA,oDACA,sDACA,oDACA,iCAA2C,kBAA+B,UAC1E,mCAA6C,kBAA+B,UAC5E,oCAA8C,kBAAiC,YAC/E,+BAA0C,mBAAuC,gBACjF,sCAAiD,mBAEjD,eAAC,mBCr1BD,CAEA,YAEA,oBAKA,GAAC,cACD,CAEA,8BAgBA,uBACA,UAOA,OANA,eACK,kBACL,sBACA,0BAEA,WAGA,cAEA,OAEA,yCACA,uCAEA,gBACA,eACA,6CACA,EAEA,gBACA,6CACA,IAEA,gBACA,QACA,8BACA,MACA,gBAAqC,EAAQ,KAC7C,cAEA,KAEA,gBACA,aAAmB,MAAoB,OACvC,SACA,0CAEA,EAEA,OAzDA,QACA,+BACA,wFACA,0BACA,yBAEA,qBACA,kBACA,mDACA,mBACA,yBAIA,WAYA,yCAgCA,gBAeA,IACA,yEACA,wDACA,kBACA,4BACO,+CACP,8BACA,eACA,yCACA,QACA,gCACA,4BACA,UACA,eACA,iCACA,KAEA,kCACA,YACA,IACA,6DACA,IAAO,QACP,mBACA,6BAEA,MACA,QAEA,mBA1CA,MACA,MACA,uCACA,qDAGA,8BACA,sBACA,eACA,UACA,4BAA2D,EAAQ,KACnE,+CAEA,aA8BA,sBACA,SACA,qBAAgB,kDAChB,YAEA,uBACA,IACA,YACA,yCAEA,cAAgB,sBAChB,4BACA,uCACA,WAEA,qBACA,UACA,UAEA,wBACA,+BACA,mBACA,yBACA,4BAEA,kBACA,IAEA,uBACA,QAAgB,uCAChB,aAEA,EAAG,qBAEH,gCACA,YAAC,mBCtJD,CAEA,YAEA,KAKA,GAAC,eACD,0BAwZA,WACA,KAAmB,MAAkB,OACrC,WAEA,kBACA,QAEA,gBA6QA,QACA,4BACA,cACA,YACA,KACA,KACA,GACA,MACA,kBACA,UAEA,CArrBA,gCACA,gBAoB2B,CAAyB,MAAd,MAItC,gBACA,SACA,eACA,OACA,oBACA,QACA,IACA,yBACA,sBACK,8CACL,mBACK,sBACL,0BACA,OACK,iBACL,yBACA,qBACK,WACL,sBACA,uBACK,4CACL,wBACA,qBACK,mBACL,mBACA,0BACA,qBACO,mBACP,iCACA,oBACA,2BACA,sCACO,uBACP,yBAEA,OAAK,wBACL,eACK,6BACL,uCACK,aAAgB,iBACrB,UACK,wBACL,mCACA,2BACA,oBACA,KACA,wBACK,oBACL,oBACA,yBAEA,gBAEA,KAEA,cACA,qBACA,QACA,4BACA,aACA,kBACA,GACA,KACA,OACA,OACA,uCACA,iBACA,SACA,CAEA,gBACA,UACA,0BACA,iBAGA,OADA,YAEA,IAIA,kBACA,MACA,YACA,cACA,MAEA,oBACA,CAEA,wDADA,UAGA,cACA,kBACA,2BACA,gBACA,IAEA,kBACA,oBACA,YACA,oBACA,cAAwB,EAAO,IAC/B,wBACA,WACA,SAIA,cACA,mBACA,kBACA,kBACA,SACA,kBAEA,UACA,UAEA,SA9IA,4CAEA,mBAiBA,MAhBA,eACA,8BACA,mBACA,sBACA,2BACA,yBACA,oCACA,uBACA,2BACA,sBACA,sBACA,OACA,gBACA,qBAEA,sBA8HA,+BACA,IACA,oBACK,YAAoB,kBACzB,WACK,yBACL,qBACK,6CACL,qBACK,kEACL,qBACK,4CACL,iBACA,WACK,oEACL,cACK,kBACL,8BACK,SACL,YACK,kBACL,YACK,cACL,+BACK,eACL,gCACK,oBACL,aACK,eACL,oBAEA,2BACA,IAEA,yBACA,cACA,mBACA,uBACA,qBACA,WACO,eACP,qBACA,WAEA,yDACA,MAEA,aACA,SAEA,YAAK,OACL,UACK,sBACL,iBAKA,cAJA,QAEA,QAIA,6BACA,oBACA,QACA,QAEA,wBACA,IAAkB,aAClB,SAAkB,uBAClB,gBAAkB,QAAe,aACjC,iCAEA,yBAA6E,6DAC7E,cACK,iBACL,UACK,aACL,gCAEA,uBACA,MAEA,6BACA,OAAkB,OAClB,KAAyB,aAAuB,WAChD,uBACA,IAEA,0BACA,OAAkB,QAAe,OACjC,gBACA,kBACA,mCACA,6BACA,KACA,SAEA,0BACA,iBAEA,SACA,aACA,uBAEA,MACA,QAEA,iCACA,qCACA,cACA,gBAEA,QAEA,cAEA,2BACA,wBACA,qBAAkB,QAAe,aACjC,aAAkB,oCAElB,0CAEA,8BACA,mBACA,+CACA,QACA,YACA,kBACA,cACA,kBACA,aACA,kBACA,YACA,kBACA,aACA,kBACA,aACA,kBACA,SACA,kBAEA,UACA,OACA,kBACA,IAEA,oCACA,OACA,OACA,SACA,6BACA,WACA,cACA,mBACA,KAEA,kCACA,cACA,KAAkB,QAAe,eACjC,KACA,cAEA,6CACA,OACA,aACA,iCACA,gCACA,WAEA,6BACA,QAEA,sCACA,OACA,mBACA,KAEA,MACA,qEACA,6EACA,gBAGA,WADA,QAGA,aACA,oBAEA,6BACA,OAAyB,aAAuB,WAChD,aAAkB,aAClB,OACA,QAEA,sBACA,OAAkB,OAClB,KAAkB,QAAe,OACjC,sBACA,oBACA,WACA,KAEA,iCACA,OAAkB,OAClB,KAAkB,QAAe,OACjC,sBACA,6CACA,SACA,gBAEA,EACA,uBACA,QAAc,SACd,qBACA,eACA,wCACA,MAEA,qBACA,oCACA,eACA,kBAQA,UAPA,yBACA,OAEA,IACA,IACA,2BACA,gBAGA,sBACA,+BACA,OACA,OAcA,uBAdwC,sBACxC,QACA,OAAoB,0BACpB,wCAEA,mCACA,SACS,oCACT,2BAAoB,uBAEpB,qCAGA,aAGA,gBACA,sBACA,qBACA,0BACA,MACA,mBAEA,QAEA,SASA,yBACA,gBAEA,OACA,yDACA,oBACA,cAEA,OACA,uDACA,kEACA,wDACA,qDACA,kFACA,wDACA,iEACA,6DACA,4DACA,yDACA,eAEA,OACA,2DACA,oBACA,iBAEA,OACA,4CACA,mEACA,6DACA,mEACA,0EACA,mFACA,4EACA,6EACA,oDACA,4DACA,kDACA,yEACA,gDACA,iEACA,yDACA,4EACA,yDACA,kEACA,sEACA,8DACA,8EACA,mFACA,wDACA,0EACA,8EACA,oDACA,8BACA,uDACA,6EACA,2EACA,oEACA,kEACA,0FACA,gEACA,6DACA,0EACA,6EACA,kEACA,2EACA,sEACA,4EACA,uDACA,8FACA,4DACA,oEACA,wEACA,sDACA,yCACA,oEACA,uEACA,yDACA,8CACA,2DACA,yEACA,uEACA,4DACA,uEACA,kHACA,4DACA,iEACA,gFACA,4DACA,mFACA,yDACA,0EACA,8DACA,8DACA,iEACA,+DACA,qEACA,0EACA,wEACA,2EACA,kDACA,yEACA,2EACA,yEACA,oFACA,wCAEA,sEACA,2EACA,uCACA,kFACA,sFACA,iEACA,sEACA,sDACA,0EACA,kBAEA,OACA,gDACA,iFACA,4EACA,oEACA,8DACA,UAEA,OAKA,EAJA,oDACA,qDACA,iBAOA,EAJA,yDACA,sCACA,aAGA,wDACA,8DACA,iEACA,mEACA,iEACA,kEACA,+DACA,6DACA,8DACA,oEACA,0DACA,kEACA,yEACA,yDACA,2EACA,kEACA,sEACA,2EACA,uEACA,iEACA,8DACA,oEACA,4EACA,mEACA,6DACA,8BACA,iBAEA,OACA,8DACA,2EACA,+DACA,sGACA,wFACA,yEACA,iFACA,iFACA,uEACA,0DACA,0EACA,kFACA,2DACA,yFACA,+EACA,oEACA,sFACA,oEACA,sBACA,kFACA,mEACA,mEACA,kDACA,oDACA,kDACA,qDACA,8EACA,wFACA,yGACA,gFACA,+EACA,qDACA,mFACA,kEACA,oEACA,qGACA,kEACA,iDACA,qDACA,oFACA,kFACA,0DACA,iEACA,4FACA,uCACA,2EACA,sDACA,2EACA,kEACA,iFACA,6CACA,uEACA,qFACA,iEACA,oEACA,+FACA,kEACA,kEACA,8EACA,0EACA,iEACA,iEACA,6BACA,sFACA,qEACA,4EACA,4FACA,4DACA,0CACA,oGACA,sEACA,uDACA,2DACA,sFACA,2EACA,gIACA,0EACA,kFACA,oDACA,2EACA,kBACA,wEACA,sDACA,uEACA,6EACA,oDACA,gEACA,kFACA,kDACA,qFACA,+DACA,mEACA,8FACA,iBACA,cAEA,6BACA,8BACA,UACA,uCAEA,iCAaA,CACA,gBACA,aACA,gBACA,qBACA,mBACA,8BACA,iBACA,qBACA,gBACA,2BACA,kBACA,eACA,SACA,WACA,OAEA,QAGA,mCACA,CACA,aACA,gBACA,qBACA,mBACA,8BACA,gBACA,gBACA,iBACA,2BACA,gBACA,kBACA,cACA,QACA,uBACS,kBACT,QACA,WAEA,oBAEA,WACA,iBACA,iBACA,mBAEA,KACA,eACA,gBACA,mBACA,0BACA,qCACA,WACA,iBACA,eACA,YACA,gBAEA,QACA,iBAGA,oCACA,CACA,aACA,gBACA,qBACA,mBACA,8BACA,gBACA,gBACA,iBACA,2BACA,gBACA,kBACA,cACA,QACA,uBACS,kBACT,QACA,WAEA,oBAEA,WACA,iBACA,cAAyB,WACzB,0BACA,wHACA,oBACA,0BACA,qCACA,YACA,gBACA,eACA,OAEA,QACA,iBAGA,mCACA,CACA,gBACA,aACA,gBACA,mBACA,8BACA,iBACA,qBACA,gBACA,gBACA,kCACA,kBACA,eACA,SACA,WACA,OAEA,QACA,iBAGA,OAAC,mBC9zBD,CAEA,YAEA,KAKA,GAAC,eACD,aAEA,uBACA,MACA,gBACA,cACA,YACA,YACA,aACA,OACA,mBACA,SACA,wDACA,6BACA,yCACA,SACA,aACA,iBACA,4BACA,+BACA,8BACA,KAEA,iBACA,gCACA,wEACA,wCACA,sBAEA,aACA,CAAS,OACT,sBACA,YAA0B,sCAC1B,aACA,IACA,eA+MA,WAAgB,aAChB,OAAmB,MAAkB,aACrC,SACA,QACA,gBACA,OACA,qBAEA,OAEA,uBACA,gBAKA,mBACA,qBAA6B,SAAoB,QACjD,4BACA,CACA,IACA,KAAO,yBACP,gBAEA,QACA,MACA,UACA,WACA,MAEA,gBACA,+BAEA,MAEA,cACA,mBACA,WACA,QAEA,gBACA,aAEA,+BACA,eAIA,4DACA,KACA,WACA,OAEA,gBACA,wBACA,YAKA,YAEA,UAEA,cACA,yBACA,0BACA,EAGA,gBACA,QACA,GACA,2CACA,YACA,KACA,KAEA,OACA,QAIA,gBAEA,gDACA,wCAEA,0BAEA,OACA,YACA,QAEA,gBACA,cAGA,uBACA,qBACA,OACA,wBALA,WACA,OAKA,cACA,WACA,aACA,SACA,wBACA,kCAGA,iBAAmB,MAAkB,OACrC,iBACA,OAEA,gBAiHA,QACA,gBACA,uBACA,YACA,KACA,KACA,mBACA,EACA,OACA,QAEA,cA6DA,qBACA,gBACA,eACA,0BAAyE,UACzE,uBAA6D,UAC7D,KACA,2BACA,eACA,oBACA,EACA,WACA,iBACA,MACA,QACA,CAEA,cA+IA,qBACA,gBACA,eACA,gBACA,mCACA,CACA,KACA,KACA,sBACA,GACA,KACA,KACA,KACA,KACA,0BACA,OAEA,uBACA,MACA,QACA,CAEA,CA7qBA,kCACA,gBAuBA,SACA,eACA,OACA,oBACA,QACA,YACA,0BACA,OAEA,mBACA,cACA,KAEA,kBACA,aACA,oBACA,WACA,MACA,WACA,UACA,cACA,WAEA,gBACA,cACA,YAEA,SACA,cACA,iCACA,eACA,UACA,MACA,qBACA,YAEA,oBACA,gBACA,oBACA,yBACA,MAEA,kBACA,OACA,mBACA,gBAEA,kBACA,OACA,UAEA,cACA,qBACA,gBACA,yBACA,cAAmD,UACnD,OACA,OACA,aACA,oBACA,MACA,QACA,CAEA,gBACA,QACA,oBACA,cACA,YACA,KACA,KACA,GACA,MACA,OACA,SAEA,gBACA,sCACA,qCACA,KAIA,OApFA,MArBA,eACA,2BACA,6BACA,cACA,gBACA,sBACA,oBACA,cACA,cACA,OACA,0BACA,0BACA,iBACA,0CACA,sCACA,qBACA,6FACA,yCAEA,2BAuFA,uBACA,OACA,UACA,oCACA,kBACA,EACA,yBAEA,KAEA,qBACA,SACA,aACA,0BACA,uBACA,gBAEA,kBAA8B,iBAAyB,QACvD,SACA,cACA,6CACA,8BAEA,UAAuB,gCACvB,yDACA,aAA4B,sBAC5B,mCACA,mCACA,aAA4B,OAC5B,6BACA,SAA0B,gBAC1B,6BACA,IACA,gBACA,KACA,KAAgC,6BAChC,6BACA,iDAGA,cACA,gBACA,oDACA,8BACA,kBAEA,eACA,SACA,0BACA,IAEA,CAMA,qCAJA,cACA,mCACA,KACA,QAGA,sBACA,gEACA,mCACA,2BAAoD,aACpD,QACA,6EACA,WACA,iBACA,SACA,oCACA,QACA,YACA,eACA,8CAA+C,eAC/C,qBAAkD,iBAClD,cACA,QACA,OACA,gCAA8C,OAC9C,mBACA,2BACA,GACA,6BAGA,2CACA,OAFA,UAIA,kBAAqE,uCACrE,8BACA,qBACA,0BACA,kBACA,UAEA,QAEA,SAaA,iEACA,sFAEA,oHAoGA,MACA,iBACA,eACA,2DACA,uEACA,qCACA,yDACA,UACA,gCACA,0BAAY,MACZ,kBAAgB,cAGhB,kDACA,MACA,qBACA,iEACA,4EACA,8EACA,0EACA,oCACA,iCACA,4EACA,qCACA,gCACA,wCACA,8BACA,4BACA,CACA,MACA,MACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,yBACA,mBACA,gBAAkC,kBAClC,mBACA,uBACA,iBACA,KAEA,sBACA,gBAAgB,cAGhB,8BACA,MACA,mBACA,iEACA,0EACA,oEACA,gFACA,yCACA,0FACA,2FACA,qEACA,2CACA,gCACA,0BACA,uFACA,gBAEA,gBAEA,6BACA,WACA,OAEA,cAAgB,cAGhB,+BACA,MACA,mBACA,6EACA,yEACA,wEACA,oFACA,0EACA,4FACA,yFACA,uEACA,iFACA,8DACA,yDACA,oFACA,wCACA,gCACA,yBACA,kBACA,cACA,QACA,WAEA,oBACA,WACA,OAIA,sBAaA,MACA,iBAGA,EACA,8EACA,wFAGA,qEACA,sFAEA,wDACA,EACA,uFACA,0FACA,iGACA,yFAGA,gFACA,8EACA,wFACA,8EAEA,4EACA,oCACA,wFACA,4DACA,mBACA,oBACA,+BACA,4BACA,gBACA,mBACA,WACA,MACA,mBACA,iBACA,UACA,aACA,cACA,iBACA,mBACA,sBACA,MACA,mBACA,SACA,cAAyB,4BACzB,gEACA,MAIA,WAEA,cAAgB,eAAgB,QAGhC,0BAkBA,MACA,iBAEA,EACA,uDACA,uCAGA,+DACA,0FACA,uFACA,qFAEA,sEAEA,EACA,8EACA,wFACA,8EAEA,4EACA,gBACA,oBACA,2BACA,iGACA,yEACA,8CACA,8BACA,kBACA,6BACA,SACA,aAEA,cAAgB,eAAgB,QAGhC,sDACA,MACA,mBACA,6CACA,mCACA,mCACA,iCACA,+BACA,wBACA,uBACA,sDACA,kCACA,yCACA,8CACA,qCACA,mEACA,8DACA,kCACA,uDACA,8BACA,yDACA,yDACA,yDACA,8BACA,+CACA,2DACA,oBACA,uCACA,cACA,sDACA,2EACA,2EACA,6BACA,0CACA,2EACA,+BACA,+BACA,4BACA,uEACA,8DACA,kEACA,+DACA,uCACA,gDACA,oCACA,6CACA,0EACA,sDACA,uEACA,oBACA,wEACA,yEACA,yDACA,kEACA,qBACA,uBACA,kBAAgB,cAGhB,8BACA,MACA,qBACA,iFACA,wFACA,2CACA,qBACA,mDACA,0BACA,kBAAgB,cAGhB,oCACA,MACA,qBACA,+EACA,sGACA,aACA,4CACA,gBACA,mBACA,UACA,SACA,EACA,4BACA,iDACA,QAEA,cAAgB,KAGhB,+BACA,MACA,mBACA,gFACA,4FACA,qBACA,uEACA,wBACA,gCACA,0BACA,kBAAgB,cAIhB,oBACA,uBAwBA,MACA,mBACA,sFACA,sFACA,sFACA,0CAEA,gBACA,qCACA,aACA,kBACA,oHACA,0EACA,yFACA,6GACA,qCACA,kCACA,gBACA,iGACA,oBACA,gCACA,uDACA,gBACA,mBACA,gBACA,mBACA,WACA,MACA,mBACA,4CACA,YACA,aACA,mBACA,mBACA,SACA,aACA,OACA,cACA,iBACA,mBACA,sBACA,MACA,uBACA,oBACA,YACA,uBAEA,YAEA,aACA,eACA,yBAAwB,QAIxB,OAAC,oBCrxBsC,aA4EA,aAClC,IAAS,EAAW,WACf,eAGL,cAAS,EAAW,WAAO,MAC5B,MAAO,GAAyD,uDAI7D,QAAG,KACG,QAAE,EACP,QACQ,gBACR,sBACQ,aACR,sBACA,SACQ,aACR,gBACQ,aAGP,kBAAE,EAAG,GAAW,WACX,gBAGZ,eAAC,CAEK,OACP,MAE6C,aAC5C,MAAc,GACI,EAAI,IAAQ,EAAW,YAAiB,EAAQ,EAG1D,mBAGD,EAAO,QAAc,OAC7B,KADO,KAGsC,aAC5C,MAAU,GAAgB,EACpB,WAAK,IAAqC,QAAtB,aAC3B,IAME,CAGS,eAEV,MAAW,GAAG,EACR,qBAAM,IAAS,EAAO,KAAY,EAAM,EAAQ,MACvD,IAuBE,CAKoB,mBAEjB,KAAC,GAAK,GAAI,EAAQ,EAAL,GAAU,IACzB,MAAmB,GAAiB,EAAgC,OACpE,KAAW,EAAO,EAEf,cAAO,EAAI,IAAS,EACf,YAA0B,MAAkB,MAAa,KAElE,IAED,MAAM,IAAU,eAClB,IAAC,oEA3K6C,WAC9C,UAQA,GAAsB,EAAG,GAAyB,KAElD,EAA8C,GAE9B,EAAI,IAAM,MAAoB,mBAC9B,EAAI,IAAM,MAAoB,mBAC9B,EAAI,IAAQ,QAAqB,oBAEjD,EAAgC,GAChB,EAAI,IAAO,OAAwB,uBACnC,EAAI,IAAO,OAAa,YAExC,EAA4C,GAC5B,EAAI,IAAQ,QAAc,aAC1B,EAAI,IAAO,OAAc,aAEzC,EAAgC,GAChB,EAAI,IAAO,OAAa,YACxB,EAAI,IAAQ,QAAgB,eAC5B,EAAI,IAAQ,QAAgB,eAE5C,EAA0C,GAC1B,EAAI,IAAY,YAAoB,mBACpC,EAAI,IAAM,MAAoB,mBAE9C,EAAkC,IAClB,EAAI,IAAQ,QAAc,aAC1B,EAAI,IAAO,OAAc,aAEzC,EAAgC,GAChB,EAAI,IAAO,OAAa,YACxB,EAAI,IAAQ,QAAa,YACzB,EAAI,IAAU,UAAa,YAC3B,EAAI,IAAO,OAAa,YAExC,EAAoC,GACpB,EAAI,IAAQ,QAAsB,qBAClC,EAAI,IAAS,SAAiB,gBAC9B,EAAI,IAAM,MAAiB,gBAC3B,EAAI,IAAM,MAAkB,iBAC5B,EAAI,IAAQ,QAAgB,eAC5B,EAAI,IAAK,KAAa,YACtB,EAAI,IAAK,KAAa,YACtB,EAAI,IAAO,OAAkB,iBAE7C,EAAoC,IACpB,EAAI,IAAM,MAAc,aAExC,EAA8B,IACd,EAAI,IAAM,MAAc,aAExC,EAAkC,IAClB,EAAI,IAAM,MAAgB,eAE1C,EAAgC,IAChB,EAAI,IAAO,OAA4B,2BAEvD,EAAsC,IACtB,EAAI,IAAM,MAAkB,iBAE5C,EAAkC,IAClB,EAAI,IAAM,MAAgB,eAuGjC,UAAwB,KAC/B,MAAa,GAAK,EAElB,KAAa,EAAU,EAAQ,SAC/B,EAAc,EAAU,EACxB,SAAkB,EAAU,OAE5B,aAAU,EAEP,QACU,GAIb,wBAFA,SAEgB,GACP,EAAM,OAAW,EAAM,MAC3B,OAAC,GAAO,KAAgB,EACxB,OAIL,KAAa,EAAe,EAAK,KAAI,IAAiB,MAEtD,KAAW,EAAW,EAAM,MAC5B,SAAW,EAAY,EAAa,WAAK,EAAe,aAExD,KAAY,EAER,OAAC,KAAgB,OAAS,GAAW,UAEpC,IAAiB,IAAT,MAEX,IAIG,SAAW,GACT,IAAC,CAAW,EAEf,OAGC,YAAC,CAAK,EAAQ,OACZ,CAAK,EACF,aAIR,aAAC,QAED,CAAa,KACG,GAAG,GAAI,GAEvB,iBAHgB,CAAO,QACvB,cAEO,CAAW,EAAM,OACtB,MAAW,GAER,WAAU,IAAY,IAAc,EAC/B,UAAI,KAAa,MACjB,GAAI,KAAW,EAAO,OACpB,QAAY,EAAI,IAAa,EAGvC,MAEU,YAAM,MAAa,EAEjC,GAAC,CAEU,CACZ,c,kBCrPD,CAEA,YAEA,eAKA,GAAC,cACD,CAKA,gCACA,MAAuB,aAAkB,YAAoB,aAC7D,MAEA,cACA,mCACA,SACA,OACA,kBACA,MAEA,iCACA,cAIA,SACA,kBACA,sBACA,IAEA,SADA,WAGA,gBACA,kBACA,gBAEA,iBACA,QAEA,kBACA,IACA,8CACA,IACA,YAGA,aAA6B,cAC7B,mBAEA,kCAEA,wCACA,iBACA,iBAEA,wBAEA,yDAEA,SAAS,KACT,mBAGA,qCACA,sBACA,SACA,IAEA,eACA,IACA,uCACA,0CACA,cACA,SACS,gBACT,eACA,YACS,qBACT,qBACA,EAEA,MAEA,IACA,sCAWA,iBAVA,aACA,gCACA,sBACS,UACT,kBAEO,QACP,eADiD,kBAGjD,WAGA,kBACA,2CACA,iCACA,uDACA,WACA,SAGA,uBACA,4BACA,SACA,UACA,SACS,QACT,2CAEA,KACA,CACA,QAEA,oBAhG8C,2BAC9C,wDAEA,oBA8FA,sBACA,QAAgB,gBAChB,iBAEA,uBACA,QAAgB,YAChB,SAEA,EAEA,8BACA,wCACA,UAEA,uBACA,UACA,OAEA,EAAG,QAEH,sCACA,2CAAgD,iBAAoB,kBACpE,gBAAC,mBClJD,CAEA,YAEA,eAKA,GAAC,eACD,aAEA,qCAEA,cAIA,qBACA,SACA,wCACA,GACA,SACA,kCACA,MAIA,kBAoEA,cACA,SACA,MAEA,kBACA,cACA,QACA,MAEA,cACA,wBACA,OAIA,cAEA,UAEA,eAEA,QAEA,YAEA,yBAEA,IACA,kBACA,SACA,MAGA,yBACA,IAEA,qCACA,qBAAsB,OACtB,MACA,IAEA,gBACA,sBACA,2BACA,YACA,0BACA,YACA,8CAEA,IAEA,wBAEA,eACA,+CACA,eACA,YAIA,sCACA,gBACA,kBACA,oDAGA,KAGA,eACA,0DAEA,GAIA,IACA,uBACA,aACA,iBAGA,wBACA,iCAEA,WACA,6CACA,0BACA,oBACA,cACA,kBACK,UACL,iBACK,8CACL,8BACA,gBACA,kBACA,+CACA,gBACA,OACK,gCACL,gCACA,uCACA,WACA,WACK,2DACL,iBAEA,wCACA,SACA,gBAGA,qBAEA,4BACA,gBAEA,mBACA,oDACA,YACA,IAAK,kCACL,sBACA,gCAEA,uDACA,8CACA,kBACA,6CACA,sBACA,EAKA,SAEA,+BACA,0BACA,oCAGA,gBAeA,cACA,iBACA,QACK,IACL,eAGA,iBACA,WAtBA,mBAKA,gBACA,IACA,iDAEA,2CARA,aAEA,mBAOA,gBACA,OAEA,KAWA,gBACA,mBACA,iBACA,uBACA,gCACA,4DACA,wBACA,gCACA,MACA,oBAEA,KACA,CACA,QAEA,gBACA,0CACA,MACA,iDACA,+BACA,sCACA,iBACA,gBACA,+BACA,OACA,UACA,kBACA,YACA,aACA,2BAEA,QAAK,UACL,gCAEA,eACA,cAEA,KAGA,cACA,OAEA,mBACA,UAEA,4DAEA,uBAAqB,iBAA6B,OAClD,8BAEA,eACA,0EAKA,QACA,2EACA,oDAEA,cAIA,SAEA,MACA,uBACA,6BAEA,UACA,yBACA,iCAGA,UACA,2BAEA,UAAyB,iBACzB,UAAqB,aACrB,MAAgC,wBAChC,iBAAwB,gBACxB,SAA2B,mBAC3B,YAAuB,eACvB,QAAwB,gBACxB,SAA+B,oCAC/B,UAA8B,sBAG9B,gBAAuB,uCAEvB,UACA,iBAGA,sDACA,2BAEA,4BAIA,iCACA,8BAEA,IAEA,cAEA,gBAEA,gBALO,MAOP,UACA,4BACK,6BACL,+DAGA,2BACA,IAEA,gBACA,UACA,YAGA,WAEA,gBACA,SACA,aACA,sBAEA,cACA,mBACA,KAGA,mBACA,OACA,kCACA,cACA,mDACA,UACA,YACA,IAEA,MACA,cAEA,gCACA,uDACA,UAGA,aAGA,sBACA,GACA,gBACA,KACA,YAEA,sBAAuD,yBACvD,6BACA,yCACA,wBAEA,QAGA,YACA,SACA,gDACA,mBACA,uBACA,gCACA,eACA,OACO,kBACP,OACA,KAEA,cADA,GAEA,UACA,aAEA,IAAK,MACL,WAGA,SACA,aACA,8BACA,OACA,oBACA,qBACA,OAGA,qBACA,qCACA,iBACA,8CACA,SAGA,wCACA,2CACA,iBACA,qDACA,SAGA,gCACA,sCACA,eACA,KAIA,SAHA,kBACA,oBACA,KAGA,gBACA,eACA,iDACA,QAGA,4BACA,sCACA,cACA,KAGA,SAFA,iCACA,6BAGA,gEACA,OACA,8CACA,cAEA,iBAEA,MAEA,OACA,UAEA,sDACA,OACA,8CACA,cAEA,iBAEA,MAEA,OACA,SAEA,0FACA,8BACA,cACA,4BACA,SAAiD,mDACjD,aACA,iBACA,iBACA,cACA,QAEA,4BACA,qBACA,aACK,0BACL,kDACA,kBACA,oBAEA,kDACA,uDACA,kBACA,UACA,8BACA,SACA,iCACA,WAEA,OACA,oCACA,SACA,qCACA,WAEA,wBACA,oEACA,wBACA,iBACA,gBACA,KAGA,iBAFA,kBACA,YAEA,CAAK,SACL,kCACA,IACA,qBAEA,eAEA,EAGA,MACA,wCACA,oBACA,sCACA,uBACA,KAEA,SADA,kBACS,YACT,sBACA,sDACA,iBAEA,IAAO,SACP,2BACA,IACA,qBAEA,eAEA,EAIA,+CACA,GACA,8CACA,eACA,KAEA,SADA,UAGA,OACA,kBACA,YACO,kBACP,kBAIA,0BACA,IAEA,gBACA,SAEA,kBACA,OACA,8CACA,cAEA,iBAEA,MAEA,OACA,UAEA,gBAEA,eACA,UAEA,gBAEA,MACA,iBAEA,cACA,sBACA,oCACA,0CACA,iBACA,YAEA,MACA,OAEA,cAMA,qBACA,SAEA,gBACA,OACA,8CACA,qBACA,KAEA,SADA,aAGA,gBACA,QACA,YACA,IACA,CAEA,gBACA,gBACA,4BACA,MACA,4CACA,UACA,YAEA,MACA,QAEA,gBACA,uBACA,OACA,8CACA,cACA,KAEA,SADA,aAGA,gBAEA,wBACA,QAEA,gBAEA,UACA,WAGA,cAEA,yBACA,SAEA,qBAEA,gGACA,oBACA,OAEA,mBAnsBA,eAEA,iBAYA,iCAIA,0BACA,mDAGA,4BAGA,gBACA,2BAEA,oBACA,mBAEA,YACA,yCAEA,kCACA,iBAGA,UACA,mDAEA,UACA,QACA,cACA,gBACA,cACA,mBACA,mBACA,aACA,WACA,qBACA,6BACA,0BACA,wBACA,iBACA,gBACA,gBACA,YACA,YACA,uBACA,sBAGA,kBACA,+BACA,+BAIA,6BACA,+BACA,iCACA,2DACA,iBACA,4BACA,6BACA,yCACA,wCACA,gDAqjBA,KACA,wDAGA,uDA6DA,sBACA,OACA,CAEA,cAAmB,OACnB,gBAAmB,OAEnB,MACA,kBACA,iBAEA,EACA,SAEA,OACA,cACA,YACA,YACA,kBACA,EACA,MACA,iBACA,SACA,EACA,MACA,YACA,kBACA,SACA,gBACA,EACA,wBACA,iBACA,qBAEA,KAEA,uBACA,OACA,KAEA,aACA,oBAEA,iBACA,6CACA,yBAEA,wBACA,uEAEA,cACA,cACA,KACA,yBACA,qBACA,iBACA,UACA,YACA,uBACA,sBACA,eACA,gBACA,YACA,cACA,gBACA,iCACA,WACA,qBACA,6BACA,qCACA,iCACA,wBAEA,YAEA,qBAGA,MAEA,mCACA,aACA,IAEA,cACA,kBACA,MAGA,qBACA,qBAGA,YAGA,4BACA,IAEA,2BACA,mBACA,cACA,2CA1tBA,QA2tBA,YACA,gCACA,eACA,KAEA,CACA,UACA,MAEA,uBACA,oBAA4C,kBAC5C,sBAAoC,0BACpC,YAAc,QACd,OAEA,wBACA,wCACA,qEACA,kBACA,IAEA,EAEA,YAEA,wBACA,sBAEA,YACA,QAAC,SAED,+BAEA,WAAC,mBC31BD,CAEA,YAEA,KAKA,GAAC,cACD,CAEA,wBACA,EAAK,oDACL,SAAK,uJACL,SAAK,4DACL,UAAK,4DACL,wBAAK,mEACL,QAAK,kDACL,OAAK,wGACL,SAAK,yDACL,SAAK,8DACL,YAAK,sEACL,UAAK,qEACL,UAAK,mEACL,SAAK,4EACL,qBAAK,wJACL,mBAAK,6FACL,UAAK,yEACL,YAAK,kEACL,SAAK,yDACL,QAAK,2CACL,SAAK,mDACL,SAAK,uCACL,OAAK,sEACL,UAAK,uDACL,WAAK,wCACL,WAAK,kEACL,iBAAK,sDACL,SAAK,iEACL,UAAK,oCACL,SAAK,6CACL,SAAK,sDACL,SAAK,sDACL,OAAK,6CACL,SAAK,6EACL,SAAK,uEACL,SAAK,sDACL,SAAK,sCACL,QAAK,sDACL,YAAK,kCACL,QAAK,iEACL,SAAK,yEACL,SAAK,+DACL,YAAK,6CACL,OAAK,yDACL,aAAK,kEACL,wCAAK,0CACL,QAAK,8EACL,kBAAK,gDACL,UAAK,yDACL,QAAK,sFACL,SAAK,gDACL,QAAK,gDACL,UAAK,uFACL,UAAK,wEACL,WAAK,qCACL,SAAK,6CACL,SAAK,kEACL,UAAK,iDACL,UAAK,yFACL,SAAK,iHACL,gFACA,UAAK,wGACL,WAAK,kFACL,YAAK,2CACL,SAAK,+BACL,WAAK,mDACL,QAAK,qDACL,QAAK,+CACL,UAAK,+EACL,QAAK,6CACL,SAAK,4EACL,SAAK,kCACL,SAAK,8CACL,QAAK,yEACL,QAAK,4DACL,QAAK,mDACL,SAAK,uCACL,QAAK,qDACL,UAAK,sCACL,QAAK,wDACL,oBAAK,sDACL,SAAK,qEACL,4CACA,QAAK,6FACL,UAAK,qEACL,SAAK,sDACL,OAAK,0CACL,QAAK,0DACL,SAAK,4CACL,YAAK,qDACL,QAAK,2GACL,WAAK,6CACL,SAAK,sFACL,SAAK,iDACL,SAAK,sFACL,UAAK,8GACL,gBAAK,4DACL,WAAK,qFACL,mBAAK,sDACL,QAAK,uCACL,OAAK,0DACL,aAAK,wEACL,SAAK,kDACL,QAAK,uDACL,UAAK,2FACL,SAAK,mDACL,QAAK,6CACL,SAAK,gDACL,UAAK,mDACL,WAAK,4DACL,QAAK,+CACL,UAAK,wHACL,eAAK,8DACL,WAAK,wEACL,UAAK,2DACL,QAAK,sDACL,SAAK,oCACL,SAAK,2DACL,sBAAK,uFACL,YAAK,+EACL,aAAK,6CACL,SAAK,wCACL,QAAK,yDACL,SAAK,oDACL,UAAK,mDACL,WAAK,oCACL,SAAK,uEACL,SAAK,8EACL,SAAK,6CACL,SAAK,yDACL,aAAK,iDACL,eAAK,uCACL,SAAK,gDACL,UAAK,0CACL,YAAK,iFACL,OAAK,+DACL,YAAK,4DACL,SAAK,oDACL,SAAK,oFACL,QAAK,+EACL,SAAK,oCACL,SAAK,uDACL,YAAK,8CACL,QAAK,0DACL,SAAK,0DACL,SAAK,yDACL,OAAK,sDACL,UAAK,4EACL,SAAK,6GACL,SAAK,gEACL,YAAK,mDACL,QAAK,oFACL,SAAK,6CACL,SAAK,uEACL,SAAK,8CACL,QAAK,wDAGL,yBAAiB,eAAgC,OACjD,QACA,qCAGA,gCACA,KACA,0BAAmB,eAAgC,WACnD,QACA,sBACA,8BAAqC,YAAuB,OAC5D,qBACA,QACA,0CACA,sDACA,0BAEA,mCACA,aAAmB,eAAgC,OACnD,WACA,4BAAmC,UAAqB,OACxD,mBAEA,QAEA,kCACA,aAAmB,eAAgC,OACnD,WACA,mCAEA,6BACA,+BACA,sBACA,sBAEA,8BACA,KACA,0BAAmB,eAAgC,WACnD,QACA,oCACA,8BAAqC,YAAuB,OAC5D,mCACA,QACA,CACA,CAAC,mBCtND,CAEA,YAEA,KAKA,GAAC,eACD,aAEA,8BAEA,2DACA,wBAEA,WACA,oBACA,SACA,WACA,aAEA,8DACA,cACA,YAGA,qBACA,0CAEA,yCACA,gBAA2B,YACpB,cAA0B,YACjC,oBACA,aACA,IACA,UAEA,qBAAiC,aAEjC,iBAAqC,gBAErC,iBAAsC,iBACtC,MAEA,YACA,wBACA,SACA,cACA,SACA,cACA,SAEA,eACA,aAIA,8BACA,gBACA,OAGA,+BACA,uBACA,IACA,UACA,eACA,OAIA,sBAEA,YAA6C,2BAAsB,WAEnE,kBAA0D,qCAE1D,0CAA6E,8BAC7E,qCAAoF,sCAEpF,cAAyC,eACzC,SAGA,wBACA,oFACA,mBACA,cAEA,wBAAgD,YAAwB,aAGxE,WACA,uBACA,UACA,OACA,KACA,uBACA,OACA,CACA,QACA,oBACA,cACA,aACA,EACA,WAEA,WAEA,EAAC,GAED,mCACA,yBAEA,OAAC,mBCpHD,CAEA,YAEA,KAKA,GAAC,eACD,aAEA,+BAEA,gBAEA,mBACA,OAAkB,MAAkB,OACpC,MAEA,OAGA,gBAcA,uBAEA,cACA,UAEA,UACA,kBACA,OAEA,2BACA,oDACA,WAEA,UACA,wBACA,QACA,YAEA,WACA,YAEA,cACA,wBACA,WAEA,mBACA,cAEA,cACA,qBACA,gBACA,MAEA,oBACA,qBACA,4BACA,eAGA,oBACA,iBACA,8CACA,+BACA,IAEA,gBACA,kBAAgD,OAChD,0BACA,gBACA,yBACA,cACA,CACA,KACA,KACA,0BACA,CACA,cACA,YACA,WACA,KACA,eACA,8BACA,QAEA,aACA,QACA,CAEA,mBADA,SAEA,CAEA,gBAaA,iBACA,WAEA,OA7GA,YAWA,0BACA,uDAGA,uDACA,0DACA,4EACA,wEACA,2EAEA,kEAyEA,0BACA,aACA,aAAc,UACd,wCAAsE,aACtE,UAEA,kCACA,eACA,QACA,MAEA,QAKA,uBAA4B,OAAQ,UACpC,qBACA,OACA,OACA,gBACA,6BACA,SAEA,QAAC,GAED,yBAEA,SACA,gCAEA,QAAC,mBC5ID,CAEA,YAEA,KAKA,GAAC,eACD,aAEA,6BACA,gBA2BA,SACA,2BACA,yBACA,OAEA,0BACA,cACA,eACO,8BACP,6CAEA,oBAEA,uCAEA,YAAsB,qBACtB,cACA,KAEA,eACA,UACA,cACA,WAEA,gBACA,cACA,YAEA,SACA,MACA,iBACA,YAEA,sBACA,8BACA,mBACA,uDACA,QAEA,qCACA,OACA,UAEA,cACA,qBACA,gBACA,yBACA,cAAmD,UACnD,eACA,OACA,gBACA,aACA,YACA,QACA,CAEA,gBACA,QACA,oBACA,cACA,GACA,WACA,KACA,GACA,MACA,OACA,SAEA,sBACA,MACA,gBACA,cACA,YACA,aACA,MACA,kBACA,8CACA,QACA,cACA,cACA,sBACA,4BACA,+BACA,8BACA,KAIA,IAzFA,OAxBA,aACA,mCACA,uDACA,mCACA,kDACA,gDACA,oCACA,qDACA,+CACA,8CACA,SAGA,WACA,iCACA,uDACA,uCACA,4BAGA,cAEA,0BA4FA,uBACA,OACA,UACA,8BACA,mBACA,EAEA,eAEA,qBACA,SACA,aACA,0BACA,uBACA,gBACA,uCAEA,yBACA,QACA,cACA,wBACA,kCAEA,UAAuB,sBACvB,2BACA,2BACA,sBACA,OAA4B,QAAmB,YAC/C,gBACA,OAEA,iBAEA,sBACA,6CACA,mCACA,4CACA,8BACA,MAEA,oBACA,kCACA,iBACA,IAEA,gBACA,qBACA,sBACA,0BACA,qBACA,iBAEA,KAAC,GAED,yBAEA,KAAC,mBCtLD,CAEA,YAEA,KAKA,GAAC,eACD,aAqxBA,eACA,kCACA,GAEA,CACA,eACA,MACA,SACA,wCAEA,gCAEA,EAEA,CACA,eACA,gBACA,iBACA,kCACA,QAEA,CACA,eACA,IAEA,OADA,YAEA,KACA,wBAIA,MAEA,CApzBA,8BAEA,sBAidA,gBACA,aACA,YACA,6BACA,kBACA,cACA,cACA,GAQA,kBAPA,UAKA,qBAJA,OACA,UAEA,UAEA,0BAEA,SACA,iBAEA,kBACA,gCACA,UACA,cACA,cACA,oBACA,iBAEA,gBACA,MACA,iBACA,WACA,qCACA,iBACA,0BACA,qFACA,oBACA,+BACA,+BACA,wBACA,8BACA,gBACA,0BACA,mBACA,SACA,eACA,+BACA,WACA,aACA,iBACA,2BACA,WACA,YACA,gBACA,kBACA,UACA,UACA,GACA,kBACA,UACA,aACA,kBACA,UACA,aACA,kBACA,UACA,aACA,kBACA,UACA,0BACA,mBACA,wBACA,gBACA,UACA,GACA,kBACA,eACA,aACA,kBACA,eACA,aACA,kBACA,UAAkF,KAClF,aACA,kBACA,eACA,0BACA,mBACA,6BACA,gBACA,UACA,GACA,kBACA,eACA,cACA,kBACA,eACA,cACA,kBACA,UAAkF,KAClF,cACA,kBACA,eACA,2BACA,mBACA,8BACA,gBACA,UACA,GACA,kBACA,UACA,aACA,kBACA,UACA,aACA,kBACA,UACA,aACA,kBACA,UACA,0BACA,mBACA,wBACA,SAAsD,0BACtD,IACA,kBACA,eACA,aACA,kBACA,eACA,aACA,kBACA,UAAkF,KAClF,aACA,kBACA,eACA,0BACA,0CACA,WACA,YACA,gBACA,mBACA,sBACA,iBACA,qBACA,YACA,qBACA,aACA,qBACA,aACA,qBACA,aACA,+BACA,WACA,OAAsC,wBACtC,OACA,aAEA,4BACA,kBACA,UACA,cAAkF,IAClF,UACA,kBACA,UACA,kBACA,0BACA,WACA,OAAsC,wBACtC,OACA,aAEA,4BACA,kBACA,UACA,cAAkF,IAClF,UACA,kBACA,UACA,kBACA,0BACA,WACA,OAAsC,wBACtC,OACA,aACA,iBAEA,6BACA,kBACA,UACA,cAAkF,IAClF,UACA,kBACA,UACA,kBACA,0BACA,IACA,wBACA,iBACA,2BACA,YAGA,SADA,qBAEA,SACA,+BAA+D,8BAC/D,WAEA,oBACA,oBACA,SACA,kEAA0H,wCAC1H,SACA,aACA,uBACA,QACA,aACA,yCAAsE,qCAA+C,MACrH,SACA,gBACA,MAEA,uBACA,IACA,QACA,sBACA,YACA,gDACA,SACA,kBACA,gCACA,iBAEA,kBACA,IACA,iBACA,IACA,qCACA,cACA,sCACA,iBACA,4CACA,iBACA,SACA,OAA+C,eAAuB,+BACtE,mBAEA,gBACA,oBACA,YACA,OACA,kBACA,6BACA,MACA,UACA,WAEA,uBAEA,SACA,IACA,cACA,KACA,UACA,KACA,MACA,KACA,OACA,KACA,WACA,KAEA,aAEA,QAhBA,OAiBA,wBACA,YACA,cACA,gBAEA,uBAEA,SACA,IACA,cACA,KACA,UACA,KACA,MACA,KACA,OACA,KACA,WACA,KAEA,aAEA,QAhBA,MAiBA,YAEA,OApvBA,MACA,OACA,OACA,OAEA,OACA,OACA,MACA,MACA,MACA,IACA,MACA,MACA,MACA,OACA,OAEA,MACA,MACA,OACA,OACA,KACA,KACA,KACA,KACA,OACA,OACA,QACA,KACA,KACA,MACA,OACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,QACA,MACA,MACA,MACA,OACA,OACA,OACA,MACA,OACA,OAEA,MACA,MACA,KACA,MAEA,WACA,UACA,YACA,aACA,WACA,WACA,eACA,cACA,UACA,gBACA,YACA,SACA,YACA,SACA,aACA,SACA,aACA,OACA,KACA,SACA,OACA,kBACA,OACA,cACA,OACA,KACA,iBACA,OACA,OACA,sBACA,QACA,OACA,gBACA,KACA,uBACA,UACA,EAAmB,KACnB,gBACA,OACA,OACA,qBACA,QACA,OACA,KACA,KACA,aACA,QACA,aACA,QACA,EAA6B,eAC7B,OACA,SACA,iBACA,QACA,OACA,EAAiC,mBACjC,QACA,QACA,SACA,SACA,gBACA,QACA,QACA,UACA,QACA,EAAyB,WACzB,UACA,QACA,OACA,SACA,YACA,QACA,EAA0B,YAC1B,EAA4B,cAC5B,EAA8B,gBAC9B,EAA+B,iBAC/B,gBACA,QACA,EAAsC,wBACtC,mBACA,QACA,KACA,SACA,OACA,EAA0B,YAC1B,YACA,OACA,EAA6B,eAC7B,aACA,OACA,EAA8B,gBAC9B,oBACA,OACA,wBACA,QACA,oBACA,OACA,sBACA,OACA,sBACA,OACA,sBACA,OACA,2BACA,QACA,EAAmC,qBACnC,EAAmC,qBACnC,QACA,UACA,OACA,UACA,0BACA,OACA,OACA,qBACA,MACA,OACA,0BACA,MACA,OACA,2BACA,OACA,QACA,oBACA,OACA,eACA,QACA,mBACA,QACA,sBACA,OACA,qBACA,OACA,gCACA,OACA,yBACA,OACA,mBACA,OACA,eACA,OACA,EAAuC,yBACvC,qBACA,QACA,2BACA,QACA,WACA,QACA,EAAiC,mBACjC,YACA,SACA,OACA,cACA,WACA,OACA,eACA,OACA,cACA,OACA,QACA,OACA,OACA,cACA,OACA,oBACA,OAEA,QACA,YACA,WACA,YACA,aACA,UACA,cAEA,OACA,SACA,QACA,QACA,OACA,UACA,QACA,YACA,QACA,SACA,QACA,QACA,QACA,OACA,QACA,MACA,SACA,QACA,WACA,UACA,cACA,OACA,QACA,WACA,UACA,UACA,UACA,SACA,MACA,KACA,OACA,OACA,WACA,aACA,YACA,cACA,WACA,aACA,MACA,OACA,OACA,SACA,OACA,MACA,QACA,SACA,QACA,OACA,SACA,WACA,OACA,WACA,WACA,WACA,gBACA,gBACA,aACA,WACA,eACA,eACA,YACA,cACA,UACA,UACA,cACA,iBACA,mBACA,cACA,WACA,WACA,WACA,gBACA,gBACA,aACA,cACA,aACA,QACA,OACA,SACA,OACA,OACA,MACA,SACA,QACA,MACA,QACA,OACA,OACA,OACA,OACA,KACA,UACA,SACA,OACA,SACA,QACA,YACA,OACA,MACA,QACA,IACA,SACA,QACA,SACA,SACA,SACA,SACA,KACA,MACA,OACA,KACA,MACA,OACA,UACA,MACA,MACA,OACA,UACA,OACA,MACA,MACA,QACA,SACA,YACA,OACA,IACA,QACA,QACA,eACA,QACA,QACA,UACA,OACA,UACA,WACA,WACA,WACA,OACA,OACA,MACA,SACA,UACA,QACA,SACA,UACA,YACA,SACA,QACA,IACA,SACA,SACA,OACA,UACA,SACA,SACA,SACA,QACA,OACA,WACA,aACA,YACA,UACA,cACA,cACA,WACA,aACA,aACA,QACA,SACA,SACA,UACA,WACA,WACA,MACA,QACA,SACA,aACA,OACA,SACA,QACA,UACA,OACA,QACA,OACA,QACA,QACA,MACA,SACA,UACA,UACA,UACA,UACA,UACA,SACA,WACA,OACA,UACA,MACA,OACA,OACA,QACA,KACA,cACA,KACA,UACA,QACA,QACA,SACA,SACA,UACA,QACA,MACA,QACA,SACA,MACA,OACA,UACA,YACA,OACA,OACA,QACA,IAEA,QACA,aAEA,wBA6SA,sBACA,OACA,CACA,iBACA,WACA,UAEA,KACA,qBACA,UACA,iBACA,cAEA,IAAC,GAED,6CAEA,2BAEA,OAkCC,mBCn0BD,CAEA,YAEA,eAKA,GAAC,cACD,CAEA,0BACA,WAAgB,aAChB,OAAmB,MAAkB,aACrC,SACA,QAGA,kBACA,oBACA,kBACA,aACA,KAAqB,MAAqB,2BAC1C,gCACA,WAEA,qBACA,OACA,QACA,CACA,gBACA,qBAAoC,OAAoD,WACxF,CACA,oBAEA,oBAA6C,kBAC7C,2BACA,KAIA,4BAEA,4CAEA,uBACA,OACA,qBACA,sCACA,yBACA,mBAGA,sBAEA,4BACA,QACA,iBAGA,oBAGA,oBAEA,SACA,WACA,iBACA,mBAA2D,yCAC3D,mBACA,YACA,gBAA6B,iBAC7B,MACA,KACA,mBACA,EACA,OACA,QAEA,OACA,qFACA,sFACA,iFACA,mFACA,wFACA,2EACA,wHACA,4mSACA,yCAEA,eACA,MACA,mBACA,eACA,qBACA,8EACA,kDACA,aACA,KACA,0BACA,cACA,mBACA,WACA,YACA,mBACA,IACA,yBACA,aACA,mBACA,mDACA,IAEA,QADA,oDAEA,kBACA,SAEA,QACA,CACA,QACA,iBACA,qCACA,aACA,SACA,iBACA,eACA,qCACA,aACA,SACA,CACA,QACA,mBACA,8CACA,gBACA,KACA,QACA,EAAQ,iBACR,CAGA,8BAFA,qCACA,OAEA,EAAQ,iBACR,CAKA,mBAJA,sDACA,+CAEA,OAKA,oCACA,kCACA,iBAEA,mBAsCA,sBACA,SACA,4CACA,YACA,OACA,gBACA,yBACA,sBACA,KAEA,uBACA,IAEA,gBADA,wDAGA,gBAAgB,+BAChB,qBACA,QAEA,EAEA,mBA1DA,SACA,8EACA,SACA,YACA,oBACA,uDACA,mBACA,IAEA,0CACA,4BACA,gBACA,QAAS,wCACT,iBACA,oBACA,KACA,wBAEA,gCACA,SACA,mCAMA,OALA,uEACA,IAAgC,UAChC,oBAEA,YACO,yCACP,SACA,uBACA,gCACA,MAEA,oBAEA,SAEA,sBAuBA,gCACA,8BACA,mBACA,2BACA,WAEA,oBACA,qBACA,iBAEA,0BAAkC,QAAS,wBAA4C,QAEvF,EAAG,cAEH,gDACA,oDAAyD,WACzD,4BACA,eAAC,mBCxOD,CAEA,YAEA,KAKA,GAAC,cACD,CAEA,0BACA,uCACA,QAEA,cAoBA,iCACA,EAEA,2BAtBA,wCACA,8CACA,qCACA,iCACA,sCACA,+DACA,+DACA,sDACA,8DACA,oDACA,qDACA,oDACA,kDACA,oDACA,yCACA,4BACA,qDAEA,8CAKA,gBAqCA,yBAEA,wCACA,YACA,uBACA,SACA,oBACA,KACA,kBACA,kBACA,eACA,IACA,OACA,OAIA,YAHA,YACA,QAGA,OACA,OAEA,gBACA,uBAEA,cAGA,UACA,gBACA,YAIA,oCACA,IAEA,MAKA,WAL0D,iCAC1D,cAA2C,kBAC3C,cAAqC,YACrC,qBAGA,MAGA,YAEA,MAgBA,+BAdA,8BAEA,+BAEA,cAEA,yCAEA,MAGA,gCACA,qBAGA,MAEA,QAGA,MACA,+BACA,aAGA,wBAAqB,MAAsB,OAC3C,2BAEA,6BAEA,kCACA,SAEA,yBACA,SAEA,YACA,SAEA,kBACA,iBAEA,eACA,6BACA,qBACA,MAIA,cAEA,SAEA,cACA,gBAOA,SACA,qBACA,kBACA,YAIA,SAGA,SAFA,mBAKA,kBATA,YACA,MACW,cAQX,MACA,uBAEA,WACA,UACA,CACA,QACA,MA3BA,yDAEA,SACA,cAEA,SAwBA,SADA,aAGA,cACA,gCACA,qBAAyB,qBACzB,gBACA,WACA,MAEA,kBACA,eAAyC,0CACzC,iBAAyB,SACzB,SACA,OACA,SAEA,gBACA,aACA,gDACA,oBACA,kBACA,KACA,aACA,SAEA,gBACA,aAEA,4BACA,kBAGA,gCACA,qCAEA,8BAEA,oCACA,eACA,wBAGA,oBACA,yBAEA,mBACA,6BACA,iBAEA,uBAAsD,kBACtD,MACA,YAA4C,gBAE5C,MAA4B,MAC5B,YACA,6CACA,aAEA,UAMA,4BALA,8CACA,gBAGA,IAGA,WA1OA,4CAEA,sFACA,8BACA,qDAAmB,MAAsB,8BAEzC,4BAEA,eACA,MACA,sCAEA,mBACA,sCAEA,oCACA,mBAEA,sBACA,yGACA,6CACA,aACA,uCAAK,KACL,sBACA,6CACA,mEACA,uDACA,oDACA,YACA,4CACA,OACA,OAGA,OAyMA,uBACA,OACA,CACA,oBAAoB,4BACpB,iBACA,YACA,KACA,iBAEA,EAEA,qBACA,SACA,iBACA,qBAEA,iBACA,4DACA,kCAEA,iBACA,WACA,eACA,OAEA,sBACA,MACA,8CAEA,gCACA,SACA,6BAGA,gBADA,EAGA,gBACA,+BAAsB,QACtB,mBACA,SAEA,UACA,QAEA,gCAEA,uCAGA,MACA,mCAJ6B,gBAAuB,IAEpD,EAGA,8CACA,4CAGA,2CAAC,mBC5UD,CAEA,YAEA,KAKA,GAAC,eACD,aAEA,+BACA,cACA,WACA,WAAqC,OAAO,UAC5C,SACA,QACA,kBAeA,mBACA,QACA,MAEA,gBACA,kCACA,wBACA,QAEA,gCACA,SACA,kCACA,qCACK,gBACL,aACA,YAEA,oBACK,qBACL,gBACA,kBACA,uBACA,wBACA,iBAAqC,aAAkB,SACvD,kBACA,oDAEA,QACA,kBAFA,UAEK,IACL,gBACA,YACK,gCACL,8DACK,YACL,oCACA,oCACA,mBACA,SACK,iBACL,uBACA,6CACK,mBACL,cACA,4CACA,QACA,OACA,QAAK,IACL,mCACA,mCAGA,sBACA,iBACA,UAIA,cACA,sBAIA,aACA,sCAEA,0BACA,YAEA,QACK,8BACL,wCACA,gBACA,mBACK,gBACL,oBACA,wBACO,cACP,YAEA,QAEA,OACK,uCACL,0BACA,yBACA,qBACA,OACK,+BAA4D,gBACjE,0BACA,IACK,QAAyB,kBAC9B,cACA,KACK,sBACL,WACK,wCACL,kBACA,0CACA,KACA,UACA,OAEA,KAEA,cACA,4BACA,KACA,0BACA,KACA,CADe,kBAEN,aACT,CADsB,sBAEtB,QACS,4BACT,CACA,KACA,KACA,GACA,OACA,KAGA,MAEA,kBADA,QAGA,cACA,cACA,gBACA,IAA6B,cAC7B,IACA,uBACA,mCAEA,4CAEA,EAAO,KACP,oDAEA,UACA,OACA,CACA,aACA,IACA,0BAEA,sBACA,mCAEA,UACA,KACA,OACA,CACA,oBACA,qBACA,IAEA,YACA,4DACA,WAGA,0BACA,kBACA,YACA,MACA,KACA,eACA,YAA2B,KAC3B,CACA,oBAA+B,oBAE/B,uCACA,KACA,KAAW,gCACX,iBACA,KACA,KAEA,OACA,OACA,CACA,QACA,CACA,cACA,qBACA,8BACA,QACA,YACA,QACA,CACA,gBACA,oCACA,kBACA,QACA,YACA,SAEA,IAvMA,OAbA,4EACA,kFACA,2EACA,oFACA,2EACA,8EAEA,qEACA,6BACA,qBACA,aAAkB,QAAY,IAAK,QACnC,WA0MA,sBACA,QAAc,SACd,aACA,WAAwB,uBACxB,YACA,yBACA,KACA,WAEA,qBACA,GACA,4BACA,kBACA,0CACA,kBACA,SACA,2BACA,+CACA,2BACA,sDACA,MACA,WACA,eACA,gCACA,qCACA,+CACA,gBACA,uCACA,aAEA,UACA,CAWA,+BAVA,iCAEA,sBAAwC,WACxC,mBAAyB,oCACzB,wBAA8C,+BAC9C,2BAEA,QACA,iCACA,gBAGA,sBACA,6CACA,qBACA,OACA,kBACA,mEACA,iCACA,0CACA,EAEA,gBACA,gDACA,SAEA,SAAC,GAED,2BAEA,OAAC","file":"highlighter.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap dd3b6adb4c67567b528f","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/* Just enough of CodeMirror to run runMode under node.js */\n\nfunction splitLines(string){return string.split(/\\r\\n?|\\n/);};\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nvar countColumn = exports.countColumn = function(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      return n + (end - i);\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n};\n\nfunction StringStream(string, tabSize, context) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.context = context\n};\n\nStringStream.prototype = {\n  eol: function() {return this.pos >= this.string.length;},\n  sol: function() {return this.pos == this.lineStart;},\n  peek: function() {return this.string.charAt(this.pos) || undefined;},\n  next: function() {\n    if (this.pos < this.string.length)\n      return this.string.charAt(this.pos++);\n  },\n  eat: function(match) {\n    var ch = this.string.charAt(this.pos);\n    if (typeof match == \"string\") var ok = ch == match;\n    else var ok = ch && (match.test ? match.test(ch) : match(ch));\n    if (ok) {++this.pos; return ch;}\n  },\n  eatWhile: function(match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start;\n  },\n  eatSpace: function() {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n    return this.pos > start;\n  },\n  skipToEnd: function() {this.pos = this.string.length;},\n  skipTo: function(ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true;}\n  },\n  backUp: function(n) {this.pos -= n;},\n  column: function() {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  },\n  indentation: function() {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  },\n  match: function(pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  },\n  current: function(){return this.string.slice(this.start, this.pos);},\n  hideFirstChars: function(n, inner) {\n    this.lineStart += n;\n    try { return inner(); }\n    finally { this.lineStart -= n; }\n  },\n  lookAhead: function(n) {\n    var line = this.context.line + n\n    return line >= this.context.lines.length ? null : this.context.lines[line]\n  }\n};\nexports.StringStream = StringStream;\n\nexports.startState = function(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true;\n};\n\nvar modes = exports.modes = {}, mimeModes = exports.mimeModes = {};\nexports.defineMode = function(name, mode) {\n  if (arguments.length > 2)\n    mode.dependencies = Array.prototype.slice.call(arguments, 2);\n  modes[name] = mode;\n};\nexports.defineMIME = function(mime, spec) { mimeModes[mime] = spec; };\n\nexports.defineMode(\"null\", function() {\n  return {token: function(stream) {stream.skipToEnd();}};\n});\nexports.defineMIME(\"text/plain\", \"null\");\n\nexports.resolveMode = function(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    spec = mimeModes[spec.name];\n  }\n  if (typeof spec == \"string\") return {name: spec};\n  else return spec || {name: \"null\"};\n};\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) target = {};\n  for (var prop in obj)\n    if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      target[prop] = obj[prop];\n  return target;\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = exports.modeExtensions = {};\nexports.extendMode = function(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n};\n\nexports.getMode = function(options, spec) {\n  var spec = exports.resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) return exports.getMode(options, \"text/plain\");\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) continue;\n      if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) modeObj.helperType = spec.helperType;\n  if (spec.modeProps) for (var prop in spec.modeProps)\n    modeObj[prop] = spec.modeProps[prop];\n\n  return modeObj;\n};\n\nexports.innerMode = function(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) break;\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state};\n}\n\nexports.registerHelper = exports.registerGlobalHelper = Math.min;\n\nexports.runMode = function(string, modespec, callback, options) {\n  var mode = exports.getMode({indentUnit: 2}, modespec);\n  var lines = splitLines(string), state = (options && options.state) || exports.startState(mode);\n  var context = {lines: lines, line: 0}\n  for (var i = 0, e = lines.length; i < e; ++i, ++context.line) {\n    if (i) callback(\"\\n\");\n    var stream = new exports.StringStream(lines[i], 4, context);\n    if (!stream.string && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      var style = mode.token(stream, state);\n      callback(stream.current(), style, i, stream.start, state);\n      stream.start = stream.pos;\n    }\n  }\n};\n\nrequire.cache[require.resolve(\"../../lib/codemirror\")] = require.cache[require.resolve(\"./runmode.node\")];\nrequire.cache[require.resolve(\"../../addon/runmode/runmode\")] = require.cache[require.resolve(\"./runmode.node\")];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/addon/runmode/runmode.node.js\n// module id = 0\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/xml/xml.js\n// module id = 1\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"type\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"class\"),\n        \"implements\": C,\n        \"namespace\": C,\n        \"module\": kw(\"module\"),\n        \"enum\": kw(\"module\"),\n\n        // scope modifiers\n        \"public\": kw(\"modifier\"),\n        \"private\": kw(\"modifier\"),\n        \"protected\": kw(\"modifier\"),\n        \"abstract\": kw(\"modifier\"),\n        \"readonly\": kw(\"modifier\"),\n\n        // types\n        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/o/i)) {\n      stream.eatWhile(/[0-7]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/b/i)) {\n      stream.eatWhile(/[01]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^\\s*[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") {\n      if (isTS && value == \"type\") {\n        cx.marked = \"keyword\"\n        return cont(typeexpr, expect(\"operator\"), typeexpr, expect(\";\"));\n      } if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"module\") return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\") return cont(pushlex(\"form\"), classExpression, poplex);\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"modifier\") {\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function typeexpr(type, value) {\n    if (type == \"variable\" || value == \"void\") {\n      if (value == \"keyof\") {\n        cx.marked = \"keyword\"\n        return cont(typeexpr)\n      } else {\n        cx.marked = \"type\"\n        return cont(afterType)\n      }\n    }\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), typeprop)\n    }\n  }\n  function typearg(type) {\n    if (type == \"variable\") return cont(typearg)\n    else if (type == \":\") return cont(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\") return cont(typeexpr)\n    if (type == \"[\") return cont(expect(\"]\"), afterType)\n    if (value == \"extends\") return cont(typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"modifier\") return cont(pattern)\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, maybetype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, functiondef)\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\" || type == \"modifier\") return cont(funarg);\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\"))\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"modifier\" || type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\") &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(isTS ? classfield : functiondef, classBody);\n    }\n    if (type == \"[\")\n      return cont(expression, expect(\"]\"), isTS ? classfield : functiondef, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    return pass(functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/javascript/javascript.js\n// module id = 2\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../javascript/javascript\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaultTags = {\n    script: [\n      [\"lang\", /(javascript|babel)/i, \"javascript\"],\n      [\"type\", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, \"javascript\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"javascript\"]\n    ],\n    style:  [\n      [\"lang\", /^css$/i, \"css\"],\n      [\"type\", /^(text\\/)?(x-)?(stylesheet|css)$/i, \"css\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"css\"]\n    ]\n  };\n\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current(), close = cur.search(pat);\n    if (close > -1) {\n      stream.backUp(cur.length - close);\n    } else if (cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n\n  var attrRegexpCache = {};\n  function getAttrRegexp(attr) {\n    var regexp = attrRegexpCache[attr];\n    if (regexp) return regexp;\n    return attrRegexpCache[attr] = new RegExp(\"\\\\s+\" + attr + \"\\\\s*=\\\\s*('|\\\")?([^'\\\"]+)('|\\\")?\\\\s*\");\n  }\n\n  function getAttrValue(text, attr) {\n    var match = text.match(getAttrRegexp(attr))\n    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : \"\"\n  }\n\n  function getTagRegexp(tagName, anchored) {\n    return new RegExp((anchored ? \"^\" : \"\") + \"<\\/\\s*\" + tagName + \"\\s*>\", \"i\");\n  }\n\n  function addTags(from, to) {\n    for (var tag in from) {\n      var dest = to[tag] || (to[tag] = []);\n      var source = from[tag];\n      for (var i = source.length - 1; i >= 0; i--)\n        dest.unshift(source[i])\n    }\n  }\n\n  function findMatchingMode(tagInfo, tagText) {\n    for (var i = 0; i < tagInfo.length; i++) {\n      var spec = tagInfo[i];\n      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];\n    }\n  }\n\n  CodeMirror.defineMode(\"htmlmixed\", function (config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"xml\",\n      htmlMode: true,\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag\n    });\n\n    var tags = {};\n    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\n    addTags(defaultTags, tags);\n    if (configTags) addTags(configTags, tags);\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)\n      tags.script.unshift([\"type\", configScript[i].matches, configScript[i].mode])\n\n    function html(stream, state) {\n      var style = htmlMode.token(stream, state.htmlState), tag = /\\btag\\b/.test(style), tagName\n      if (tag && !/[<>\\s\\/]/.test(stream.current()) &&\n          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&\n          tags.hasOwnProperty(tagName)) {\n        state.inTag = tagName + \" \"\n      } else if (state.inTag && tag && />$/.test(stream.current())) {\n        var inTag = /^([\\S]+) (.*)/.exec(state.inTag)\n        state.inTag = null\n        var modeSpec = stream.current() == \">\" && findMatchingMode(tags[inTag[1]], inTag[2])\n        var mode = CodeMirror.getMode(config, modeSpec)\n        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);\n        state.token = function (stream, state) {\n          if (stream.match(endTagA, false)) {\n            state.token = html;\n            state.localState = state.localMode = null;\n            return null;\n          }\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n        };\n        state.localMode = mode;\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, \"\"));\n      } else if (state.inTag) {\n        state.inTag += stream.current()\n        if (stream.eol()) state.inTag += \" \"\n      }\n      return style;\n    };\n\n    return {\n      startState: function () {\n        var state = CodeMirror.startState(htmlMode);\n        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};\n      },\n\n      copyState: function (state) {\n        var local;\n        if (state.localState) {\n          local = CodeMirror.copyState(state.localMode, state.localState);\n        }\n        return {token: state.token, inTag: state.inTag,\n                localMode: state.localMode, localState: local,\n                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n      },\n\n      token: function (stream, state) {\n        return state.token(stream, state);\n      },\n\n      indent: function (state, textAfter, line) {\n        if (!state.localMode || /^\\s*<\\//.test(textAfter))\n          return htmlMode.indent(state.htmlState, textAfter);\n        else if (state.localMode.indent)\n          return state.localMode.indent(state.localState, textAfter, line);\n        else\n          return CodeMirror.Pass;\n      },\n\n      innerMode: function (state) {\n        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n      }\n    };\n  }, \"xml\", \"javascript\", \"css\");\n\n  CodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/htmlmixed/htmlmixed.js\n// module id = 3\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"css\", function(config, parserConfig) {\n  var inline = parserConfig.inline\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode(\"text/css\");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      documentTypes = parserConfig.documentTypes || {},\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      counterDescriptors = parserConfig.counterDescriptors || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      allowNested = parserConfig.allowNested,\n      lineComment = parserConfig.lineComment,\n      supportsAtComponent = parserConfig.supportsAtComponent === true;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == \"@\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"def\", stream.current());\n    } else if (ch == \"=\" || (ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) {\n      return ret(null, \"compare\");\n    } else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \"#\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"atom\", \"hash\");\n    } else if (ch == \"!\") {\n      stream.match(/^\\s*\\w*/);\n      return ret(\"keyword\", \"important\");\n    } else if (/\\d/.test(ch) || ch == \".\" && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret(\"number\", \"unit\");\n    } else if (ch === \"-\") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret(\"number\", \"unit\");\n      } else if (stream.match(/^-[\\w\\\\\\-]+/)) {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ret(\"variable-2\", \"variable-definition\");\n        return ret(\"variable-2\", \"variable\");\n      } else if (stream.match(/^\\w+-/)) {\n        return ret(\"meta\", \"meta\");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, \"select-op\");\n    } else if (ch == \".\" && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret(\"qualifier\", \"qualifier\");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if ((ch == \"u\" && stream.match(/rl(-prefix)?\\(/)) ||\n               (ch == \"d\" && stream.match(\"omain(\")) ||\n               (ch == \"r\" && stream.match(\"egexp(\"))) {\n      stream.backUp(1);\n      state.tokenize = tokenParenthesized;\n      return ret(\"property\", \"word\");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"property\", \"word\");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == \")\") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\\"\\')]/, false))\n      state.tokenize = tokenString(\")\");\n    else\n      state.tokenize = null;\n    return ret(null, \"(\");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type, indent) {\n    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    if (state.context.prev)\n      state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = \"atom\";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = \"keyword\";\n    else\n      override = \"variable\";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == \"{\") {\n      return pushContext(state, stream, \"block\");\n    } else if (type == \"}\" && state.context.prev) {\n      return popContext(state);\n    } else if (supportsAtComponent && /@component/.test(type)) {\n      return pushContext(state, stream, \"atComponentBlock\");\n    } else if (/^@(-moz-)?document$/.test(type)) {\n      return pushContext(state, stream, \"documentTypes\");\n    } else if (/^@(media|supports|(-moz-)?document|import)$/.test(type)) {\n      return pushContext(state, stream, \"atBlock\");\n    } else if (/^@(font-face|counter-style)/.test(type)) {\n      state.stateArg = type;\n      return \"restricted_atBlock_before\";\n    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {\n      return \"keyframes\";\n    } else if (type && type.charAt(0) == \"@\") {\n      return pushContext(state, stream, \"at\");\n    } else if (type == \"hash\") {\n      override = \"builtin\";\n    } else if (type == \"word\") {\n      override = \"tag\";\n    } else if (type == \"variable-definition\") {\n      return \"maybeprop\";\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    } else if (type == \":\") {\n      return \"pseudo\";\n    } else if (allowNested && type == \"(\") {\n      return pushContext(state, stream, \"parens\");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (propertyKeywords.hasOwnProperty(word)) {\n        override = \"property\";\n        return \"maybeprop\";\n      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n        override = \"string-2\";\n        return \"maybeprop\";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? \"property\" : \"tag\";\n        return \"block\";\n      } else {\n        override += \" error\";\n        return \"maybeprop\";\n      }\n    } else if (type == \"meta\") {\n      return \"block\";\n    } else if (!allowNested && (type == \"hash\" || type == \"qualifier\")) {\n      override = \"error\";\n      return \"block\";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == \":\") return pushContext(state, stream, \"prop\");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" && allowNested) return pushContext(state, stream, \"propBlock\");\n    if (type == \"}\" || type == \"{\") return popAndPass(type, stream, state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n\n    if (type == \"hash\" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {\n      override += \" error\";\n    } else if (type == \"word\") {\n      wordAsValue(stream);\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    }\n    return \"prop\";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"word\") { override = \"property\"; return \"maybeprop\"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \")\") return popContext(state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n    if (type == \"word\") wordAsValue(stream);\n    return \"parens\";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == \"meta\") return \"pseudo\";\n\n    if (type == \"word\") {\n      override = \"variable-3\";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.documentTypes = function(type, stream, state) {\n    if (type == \"word\" && documentTypes.hasOwnProperty(stream.current())) {\n      override = \"tag\";\n      return state.context.type;\n    } else {\n      return states.atBlock(type, stream, state);\n    }\n  };\n\n  states.atBlock = function(type, stream, state) {\n    if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\n    if (type == \"}\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"{\") return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\");\n\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (word == \"only\" || word == \"not\" || word == \"and\" || word == \"or\")\n        override = \"keyword\";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = \"attribute\";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = \"property\";\n      else if (mediaValueKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else if (propertyKeywords.hasOwnProperty(word))\n        override = \"property\";\n      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n        override = \"string-2\";\n      else if (valueKeywords.hasOwnProperty(word))\n        override = \"atom\";\n      else if (colorKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else\n        override = \"error\";\n    }\n    return state.context.type;\n  };\n\n  states.atComponentBlock = function(type, stream, state) {\n    if (type == \"}\")\n      return popAndPass(type, stream, state);\n    if (type == \"{\")\n      return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\", false);\n    if (type == \"word\")\n      override = \"error\";\n    return state.context.type;\n  };\n\n  states.atBlock_parens = function(type, stream, state) {\n    if (type == \")\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state, 2);\n    return states.atBlock(type, stream, state);\n  };\n\n  states.restricted_atBlock_before = function(type, stream, state) {\n    if (type == \"{\")\n      return pushContext(state, stream, \"restricted_atBlock\");\n    if (type == \"word\" && state.stateArg == \"@counter-style\") {\n      override = \"variable\";\n      return \"restricted_atBlock_before\";\n    }\n    return pass(type, stream, state);\n  };\n\n  states.restricted_atBlock = function(type, stream, state) {\n    if (type == \"}\") {\n      state.stateArg = null;\n      return popContext(state);\n    }\n    if (type == \"word\") {\n      if ((state.stateArg == \"@font-face\" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\n          (state.stateArg == \"@counter-style\" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\n        override = \"error\";\n      else\n        override = \"property\";\n      return \"maybeprop\";\n    }\n    return \"restricted_atBlock\";\n  };\n\n  states.keyframes = function(type, stream, state) {\n    if (type == \"word\") { override = \"variable\"; return \"keyframes\"; }\n    if (type == \"{\") return pushContext(state, stream, \"top\");\n    return pass(type, stream, state);\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"tag\";\n    else if (type == \"hash\") override = \"builtin\";\n    return \"at\";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"{\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"variable\";\n    else if (type != \"variable\" && type != \"(\" && type != \")\") override = \"error\";\n    return \"interpolation\";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: inline ? \"block\" : \"top\",\n              stateArg: null,\n              context: new Context(inline ? \"block\" : \"top\", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == \"object\") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      if (type != \"comment\")\n        state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.type == \"prop\" && (ch == \"}\" || ch == \")\")) cx = cx.prev;\n      if (cx.prev) {\n        if (ch == \"}\" && (cx.type == \"block\" || cx.type == \"top\" ||\n                          cx.type == \"interpolation\" || cx.type == \"restricted_atBlock\")) {\n          // Resume indentation from parent context.\n          cx = cx.prev;\n          indent = cx.indent;\n        } else if (ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\n            ch == \"{\" && (cx.type == \"at\" || cx.type == \"atBlock\")) {\n          // Dedent relative to current context.\n          indent = Math.max(0, cx.indent - indentUnit);\n        }\n      }\n      return indent;\n    },\n\n    electricChars: \"}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    blockCommentContinue: \" * \",\n    lineComment: lineComment,\n    fold: \"brace\"\n  };\n});\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i].toLowerCase()] = true;\n    }\n    return keys;\n  }\n\n  var documentTypes_ = [\n    \"domain\", \"regexp\", \"url\", \"url-prefix\"\n  ], documentTypes = keySet(documentTypes_);\n\n  var mediaTypes_ = [\n    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\n    \"tty\", \"tv\", \"embossed\"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\n    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\n    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\n    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\n    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\n    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\n    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\n    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\", \"orientation\",\n    \"device-pixel-ratio\", \"min-device-pixel-ratio\", \"max-device-pixel-ratio\",\n    \"pointer\", \"any-pointer\", \"hover\", \"any-hover\"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var mediaValueKeywords_ = [\n    \"landscape\", \"portrait\", \"none\", \"coarse\", \"fine\", \"on-demand\", \"hover\",\n    \"interlace\", \"progressive\"\n  ], mediaValueKeywords = keySet(mediaValueKeywords_);\n\n  var propertyKeywords_ = [\n    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\n    \"alignment-baseline\", \"anchor-point\", \"animation\", \"animation-delay\",\n    \"animation-direction\", \"animation-duration\", \"animation-fill-mode\",\n    \"animation-iteration-count\", \"animation-name\", \"animation-play-state\",\n    \"animation-timing-function\", \"appearance\", \"azimuth\", \"backface-visibility\",\n    \"background\", \"background-attachment\", \"background-blend-mode\", \"background-clip\",\n    \"background-color\", \"background-image\", \"background-origin\", \"background-position\",\n    \"background-repeat\", \"background-size\", \"baseline-shift\", \"binding\",\n    \"bleed\", \"bookmark-label\", \"bookmark-level\", \"bookmark-state\",\n    \"bookmark-target\", \"border\", \"border-bottom\", \"border-bottom-color\",\n    \"border-bottom-left-radius\", \"border-bottom-right-radius\",\n    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\n    \"border-color\", \"border-image\", \"border-image-outset\",\n    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\n    \"border-image-width\", \"border-left\", \"border-left-color\",\n    \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\",\n    \"border-right-color\", \"border-right-style\", \"border-right-width\",\n    \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\",\n    \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\",\n    \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\",\n    \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\",\n    \"caption-side\", \"caret-color\", \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\",\n    \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\",\n    \"column-rule-style\", \"column-rule-width\", \"column-span\", \"column-width\",\n    \"columns\", \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\",\n    \"cue-after\", \"cue-before\", \"cursor\", \"direction\", \"display\",\n    \"dominant-baseline\", \"drop-initial-after-adjust\",\n    \"drop-initial-after-align\", \"drop-initial-before-adjust\",\n    \"drop-initial-before-align\", \"drop-initial-size\", \"drop-initial-value\",\n    \"elevation\", \"empty-cells\", \"fit\", \"fit-position\", \"flex\", \"flex-basis\",\n    \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\",\n    \"float\", \"float-offset\", \"flow-from\", \"flow-into\", \"font\", \"font-feature-settings\",\n    \"font-family\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\",\n    \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\",\n    \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\",\n    \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\",\n    \"font-weight\", \"grid\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\",\n    \"grid-auto-rows\", \"grid-column\", \"grid-column-end\", \"grid-column-gap\",\n    \"grid-column-start\", \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\",\n    \"grid-row-start\", \"grid-template\", \"grid-template-areas\", \"grid-template-columns\",\n    \"grid-template-rows\", \"hanging-punctuation\", \"height\", \"hyphens\",\n    \"icon\", \"image-orientation\", \"image-rendering\", \"image-resolution\",\n    \"inline-box-align\", \"justify-content\", \"justify-items\", \"justify-self\", \"left\", \"letter-spacing\",\n    \"line-break\", \"line-height\", \"line-stacking\", \"line-stacking-ruby\",\n    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\n    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\n    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n    \"marks\", \"marquee-direction\", \"marquee-loop\",\n    \"marquee-play-count\", \"marquee-speed\", \"marquee-style\", \"max-height\",\n    \"max-width\", \"min-height\", \"min-width\", \"move-to\", \"nav-down\", \"nav-index\",\n    \"nav-left\", \"nav-right\", \"nav-up\", \"object-fit\", \"object-position\",\n    \"opacity\", \"order\", \"orphans\", \"outline\",\n    \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\",\n    \"overflow\", \"overflow-style\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\",\n    \"padding\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\",\n    \"page\", \"page-break-after\", \"page-break-before\", \"page-break-inside\",\n    \"page-policy\", \"pause\", \"pause-after\", \"pause-before\", \"perspective\",\n    \"perspective-origin\", \"pitch\", \"pitch-range\", \"place-content\", \"place-items\", \"place-self\", \"play-during\", \"position\",\n    \"presentation-level\", \"punctuation-trim\", \"quotes\", \"region-break-after\",\n    \"region-break-before\", \"region-break-inside\", \"region-fragment\",\n    \"rendering-intent\", \"resize\", \"rest\", \"rest-after\", \"rest-before\", \"richness\",\n    \"right\", \"rotation\", \"rotation-point\", \"ruby-align\", \"ruby-overhang\",\n    \"ruby-position\", \"ruby-span\", \"shape-image-threshold\", \"shape-inside\", \"shape-margin\",\n    \"shape-outside\", \"size\", \"speak\", \"speak-as\", \"speak-header\",\n    \"speak-numeral\", \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\",\n    \"tab-size\", \"table-layout\", \"target\", \"target-name\", \"target-new\",\n    \"target-position\", \"text-align\", \"text-align-last\", \"text-decoration\",\n    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\n    \"text-decoration-style\", \"text-emphasis\", \"text-emphasis-color\",\n    \"text-emphasis-position\", \"text-emphasis-style\", \"text-height\",\n    \"text-indent\", \"text-justify\", \"text-outline\", \"text-overflow\", \"text-shadow\",\n    \"text-size-adjust\", \"text-space-collapse\", \"text-transform\", \"text-underline-position\",\n    \"text-wrap\", \"top\", \"transform\", \"transform-origin\", \"transform-style\",\n    \"transition\", \"transition-delay\", \"transition-duration\",\n    \"transition-property\", \"transition-timing-function\", \"unicode-bidi\",\n    \"user-select\", \"vertical-align\", \"visibility\", \"voice-balance\", \"voice-duration\",\n    \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\", \"voice-stress\",\n    \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\", \"will-change\", \"word-break\",\n    \"word-spacing\", \"word-wrap\", \"z-index\",\n    // SVG-specific\n    \"clip-path\", \"clip-rule\", \"mask\", \"enable-background\", \"filter\", \"flood-color\",\n    \"flood-opacity\", \"lighting-color\", \"stop-color\", \"stop-opacity\", \"pointer-events\",\n    \"color-interpolation\", \"color-interpolation-filters\",\n    \"color-rendering\", \"fill\", \"fill-opacity\", \"fill-rule\", \"image-rendering\",\n    \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"shape-rendering\", \"stroke\",\n    \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\",\n    \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"text-rendering\",\n    \"baseline-shift\", \"dominant-baseline\", \"glyph-orientation-horizontal\",\n    \"glyph-orientation-vertical\", \"text-anchor\", \"writing-mode\"\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var nonStandardPropertyKeywords_ = [\n    \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-dark-shadow-color\",\n    \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\",\n    \"scrollbar-3d-light-color\", \"scrollbar-track-color\", \"shape-inside\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\", \"searchfield-results-button\",\n    \"searchfield-results-decoration\", \"zoom\"\n  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\n  var fontProperties_ = [\n    \"font-family\", \"src\", \"unicode-range\", \"font-variant\", \"font-feature-settings\",\n    \"font-stretch\", \"font-weight\", \"font-style\"\n  ], fontProperties = keySet(fontProperties_);\n\n  var counterDescriptors_ = [\n    \"additive-symbols\", \"fallback\", \"negative\", \"pad\", \"prefix\", \"range\",\n    \"speak-as\", \"suffix\", \"symbols\", \"system\"\n  ], counterDescriptors = keySet(counterDescriptors_);\n\n  var colorKeywords_ = [\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"afar\",\n    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\",\n    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\n    \"arabic-indic\", \"armenian\", \"asterisks\", \"attr\", \"auto\", \"auto-flow\", \"avoid\", \"avoid-column\", \"avoid-page\",\n    \"avoid-region\", \"background\", \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\",\n    \"bengali\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"cambodian\",\n    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\n    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-decimal\", \"cjk-earthly-branch\",\n    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\n    \"col-resize\", \"collapse\", \"color\", \"color-burn\", \"color-dodge\", \"column\", \"column-reverse\",\n    \"compact\", \"condensed\", \"contain\", \"content\", \"contents\",\n    \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\", \"crop\",\n    \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"darken\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"dense\", \"destination-atop\",\n    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\", \"difference\",\n    \"disc\", \"discard\", \"disclosure-closed\", \"disclosure-open\", \"document\",\n    \"dot-dash\", \"dot-dot-dash\",\n    \"dotted\", \"double\", \"down\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\n    \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\n    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\n    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\n    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\n    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\n    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\", \"ethiopic-halehame-tig\",\n    \"ethiopic-numeric\", \"ew-resize\", \"exclusion\", \"expanded\", \"extends\", \"extra-condensed\",\n    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\",\n    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"graytext\", \"grid\", \"groove\",\n    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hard-light\", \"hebrew\",\n    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\n    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"hue\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\n    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\n    \"inline-block\", \"inline-flex\", \"inline-grid\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\n    \"italic\", \"japanese-formal\", \"japanese-informal\", \"justify\", \"kannada\",\n    \"katakana\", \"katakana-iroha\", \"keep-all\", \"khmer\",\n    \"korean-hangul-formal\", \"korean-hanja-formal\", \"korean-hanja-informal\",\n    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\", \"lighten\",\n    \"line-through\", \"linear\", \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\n    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\n    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\n    \"lower-roman\", \"lowercase\", \"ltr\", \"luminosity\", \"malayalam\", \"match\", \"matrix\", \"matrix3d\",\n    \"media-controls-background\", \"media-current-time-display\",\n    \"media-fullscreen-button\", \"media-mute-button\", \"media-play-button\",\n    \"media-return-to-realtime-button\", \"media-rewind-button\",\n    \"media-seek-back-button\", \"media-seek-forward-button\", \"media-slider\",\n    \"media-sliderthumb\", \"media-time-remaining-display\", \"media-volume-slider\",\n    \"media-volume-slider-container\", \"media-volume-sliderthumb\", \"medium\",\n    \"menu\", \"menulist\", \"menulist-button\", \"menulist-text\",\n    \"menulist-textfield\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"multiply\", \"myanmar\", \"n-resize\",\n    \"narrower\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\n    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\n    \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"opacity\", \"open-quote\",\n    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\n    \"outside\", \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\",\n    \"painted\", \"page\", \"paused\", \"persian\", \"perspective\", \"plus-darker\", \"plus-lighter\",\n    \"pointer\", \"polygon\", \"portrait\", \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\",\n    \"progress\", \"push-button\", \"radial-gradient\", \"radio\", \"read-only\",\n    \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\",\n    \"relative\", \"repeat\", \"repeating-linear-gradient\",\n    \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\",\n    \"rotateZ\", \"round\", \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\",\n    \"s-resize\", \"sans-serif\", \"saturation\", \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\", \"screen\",\n    \"scroll\", \"scrollbar\", \"scroll-position\", \"se-resize\", \"searchfield\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\", \"self-start\", \"self-end\",\n    \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\", \"sidama\",\n    \"simp-chinese-formal\", \"simp-chinese-informal\", \"single\",\n    \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\n    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"soft-light\", \"solid\", \"somali\",\n    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"space-around\", \"space-between\", \"space-evenly\", \"spell-out\", \"square\",\n    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\", \"sub\",\n    \"subpixel-antialiased\", \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"system-ui\", \"table\",\n    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\n    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\n    \"tamil\",\n    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\n    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\n    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\n    \"trad-chinese-formal\", \"trad-chinese-informal\", \"transform\",\n    \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\",\n    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"unset\", \"up\",\n    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\n    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\n    \"var\", \"vertical\", \"vertical-text\", \"visible\", \"visibleFill\", \"visiblePainted\",\n    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\",\n    \"window\", \"windowframe\", \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\",\n    \"xx-large\", \"xx-small\"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\n    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\n    .concat(valueKeywords_);\n  CodeMirror.registerHelper(\"hintWords\", \"css\", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == \"/\") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return [\"comment\", \"comment\"];\n  }\n\n  CodeMirror.defineMIME(\"text/css\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-scss\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \":\": function(stream) {\n        if (stream.match(/\\s*\\{/, false))\n          return [null, null]\n        return false;\n      },\n      \"$\": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"#\": function(stream) {\n        if (!stream.eat(\"{\")) return false;\n        return [null, \"interpolation\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"scss\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-less\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \"@\": function(stream) {\n        if (stream.eat(\"{\")) return [null, \"interpolation\"];\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"&\": function() {\n        return [\"atom\", \"atom\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"less\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-gss\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    supportsAtComponent: true,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\",\n    helperType: \"gss\"\n  });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/css/css.js\n// module id = 4\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction Context(indented, column, type, info, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.info = info;\n  this.align = align;\n  this.prev = prev;\n}\nfunction pushContext(state, col, type, info) {\n  var indent = state.indented;\n  if (state.context && state.context.type == \"statement\" && type != \"statement\")\n    indent = state.context.indented;\n  return state.context = new Context(indent, col, type, info, null, state.context);\n}\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == \")\" || t == \"]\" || t == \"}\")\n    state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\nfunction typeBefore(stream, state, pos) {\n  if (state.prevToken == \"variable\" || state.prevToken == \"type\") return true;\n  if (/\\S(?:[^- ]>|[*\\]])\\s*$|\\*$/.test(stream.string.slice(0, pos))) return true;\n  if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;\n}\n\nfunction isTopScope(context) {\n  for (;;) {\n    if (!context || context.type == \"top\") return true;\n    if (context.type == \"}\" && context.prev.info != \"namespace\") return false;\n    context = context.prev;\n  }\n}\n\nCodeMirror.defineMode(\"clike\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit,\n      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      keywords = parserConfig.keywords || {},\n      types = parserConfig.types || {},\n      builtin = parserConfig.builtin || {},\n      blockKeywords = parserConfig.blockKeywords || {},\n      defKeywords = parserConfig.defKeywords || {},\n      atoms = parserConfig.atoms || {},\n      hooks = parserConfig.hooks || {},\n      multiLineStrings = parserConfig.multiLineStrings,\n      indentStatements = parserConfig.indentStatements !== false,\n      indentSwitch = parserConfig.indentSwitch !== false,\n      namespaceSeparator = parserConfig.namespaceSeparator,\n      isPunctuationChar = parserConfig.isPunctuationChar || /[\\[\\]{}\\(\\),;\\:\\.]/,\n      numberStart = parserConfig.numberStart || /[\\d\\.]/,\n      number = parserConfig.number || /^(?:0x[a-f\\d]+|0b[01]+|(?:\\d+\\.?\\d*|\\.\\d+)(?:e[-+]?\\d+)?)(u|ll?|l|f)?/i,\n      isOperatorChar = parserConfig.isOperatorChar || /[+\\-*&%=<>!?|\\/]/,\n      isIdentifierChar = parserConfig.isIdentifierChar || /[\\w\\$_\\xa1-\\uffff]/;\n\n  var curPunc, isDefKeyword;\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (hooks[ch]) {\n      var result = hooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    if (isPunctuationChar.test(ch)) {\n      curPunc = ch;\n      return null;\n    }\n    if (numberStart.test(ch)) {\n      stream.backUp(1)\n      if (stream.match(number)) return \"number\"\n      stream.next()\n    }\n    if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n    }\n    if (isOperatorChar.test(ch)) {\n      while (!stream.match(/^\\/[\\/*]/, false) && stream.eat(isOperatorChar)) {}\n      return \"operator\";\n    }\n    stream.eatWhile(isIdentifierChar);\n    if (namespaceSeparator) while (stream.match(namespaceSeparator))\n      stream.eatWhile(isIdentifierChar);\n\n    var cur = stream.current();\n    if (contains(keywords, cur)) {\n      if (contains(blockKeywords, cur)) curPunc = \"newstatement\";\n      if (contains(defKeywords, cur)) isDefKeyword = true;\n      return \"keyword\";\n    }\n    if (contains(types, cur)) return \"type\";\n    if (contains(builtin, cur)) {\n      if (contains(blockKeywords, cur)) curPunc = \"newstatement\";\n      return \"builtin\";\n    }\n    if (contains(atoms, cur)) return \"atom\";\n    return \"variable\";\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = null;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function maybeEOL(stream, state) {\n    if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))\n      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      return {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", null, false),\n        indented: 0,\n        startOfLine: true,\n        prevToken: null\n      };\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (stream.eatSpace()) { maybeEOL(stream, state); return null; }\n      curPunc = isDefKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == \";\" || curPunc == \":\" || (curPunc == \",\" && stream.match(/^\\s*(?:\\/\\/.*)?$/, false)))\n        while (state.context.type == \"statement\") popContext(state);\n      else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n      else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n      else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n      else if (curPunc == \"}\") {\n        while (ctx.type == \"statement\") ctx = popContext(state);\n        if (ctx.type == \"}\") ctx = popContext(state);\n        while (ctx.type == \"statement\") ctx = popContext(state);\n      }\n      else if (curPunc == ctx.type) popContext(state);\n      else if (indentStatements &&\n               (((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != \";\") ||\n                (ctx.type == \"statement\" && curPunc == \"newstatement\"))) {\n        pushContext(state, stream.column(), \"statement\", stream.current());\n      }\n\n      if (style == \"variable\" &&\n          ((state.prevToken == \"def\" ||\n            (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&\n             isTopScope(state.context) && stream.match(/^\\s*\\(/, false)))))\n        style = \"def\";\n\n      if (hooks.token) {\n        var result = hooks.token(stream, state, style);\n        if (result !== undefined) style = result;\n      }\n\n      if (style == \"def\" && parserConfig.styleDefs === false) style = \"variable\";\n\n      state.startOfLine = false;\n      state.prevToken = isDefKeyword ? \"def\" : style || curPunc;\n      maybeEOL(stream, state);\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine) return CodeMirror.Pass;\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      if (parserConfig.dontIndentStatements)\n        while (ctx.type == \"statement\" && parserConfig.dontIndentStatements.test(ctx.info))\n          ctx = ctx.prev\n      if (hooks.indent) {\n        var hook = hooks.indent(state, ctx, textAfter);\n        if (typeof hook == \"number\") return hook\n      }\n      var closing = firstChar == ctx.type;\n      var switchBlock = ctx.prev && ctx.prev.info == \"switch\";\n      if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {\n        while (ctx.type != \"top\" && ctx.type != \"}\") ctx = ctx.prev\n        return ctx.indented\n      }\n      if (ctx.type == \"statement\")\n        return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);\n      if (ctx.align && (!dontAlignCalls || ctx.type != \")\"))\n        return ctx.column + (closing ? 0 : 1);\n      if (ctx.type == \")\" && !closing)\n        return ctx.indented + statementIndentUnit;\n\n      return ctx.indented + (closing ? 0 : indentUnit) +\n        (!closing && switchBlock && !/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 0);\n    },\n\n    electricInput: indentSwitch ? /^\\s*(?:case .*?:|default:|\\{\\}?|\\})$/ : /^\\s*[{}]$/,\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    blockCommentContinue: \" * \",\n    lineComment: \"//\",\n    fold: \"brace\"\n  };\n});\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n  function contains(words, word) {\n    if (typeof words === \"function\") {\n      return words(word);\n    } else {\n      return words.propertyIsEnumerable(word);\n    }\n  }\n  var cKeywords = \"auto if break case register continue return default do sizeof \" +\n    \"static else struct switch extern typedef union for goto while enum const volatile\";\n  var cTypes = \"int long char short double float unsigned signed void size_t ptrdiff_t\";\n\n  function cppHook(stream, state) {\n    if (!state.startOfLine) return false\n    for (var ch, next = null; ch = stream.peek();) {\n      if (ch == \"\\\\\" && stream.match(/^.$/)) {\n        next = cppHook\n        break\n      } else if (ch == \"/\" && stream.match(/^\\/[\\/\\*]/, false)) {\n        break\n      }\n      stream.next()\n    }\n    state.tokenize = next\n    return \"meta\"\n  }\n\n  function pointerHook(_stream, state) {\n    if (state.prevToken == \"type\") return \"type\";\n    return false;\n  }\n\n  function cpp14Literal(stream) {\n    stream.eatWhile(/[\\w\\.']/);\n    return \"number\";\n  }\n\n  function cpp11StringHook(stream, state) {\n    stream.backUp(1);\n    // Raw strings.\n    if (stream.match(/(R|u8R|uR|UR|LR)/)) {\n      var match = stream.match(/\"([^\\s\\\\()]{0,16})\\(/);\n      if (!match) {\n        return false;\n      }\n      state.cpp11RawStringDelim = match[1];\n      state.tokenize = tokenRawString;\n      return tokenRawString(stream, state);\n    }\n    // Unicode strings/chars.\n    if (stream.match(/(u8|u|U|L)/)) {\n      if (stream.match(/[\"']/, /* eat */ false)) {\n        return \"string\";\n      }\n      return false;\n    }\n    // Ignore this hook.\n    stream.next();\n    return false;\n  }\n\n  function cppLooksLikeConstructor(word) {\n    var lastTwo = /(\\w+)::~?(\\w+)$/.exec(word);\n    return lastTwo && lastTwo[1] == lastTwo[2];\n  }\n\n  // C#-style strings where \"\" escapes a quote.\n  function tokenAtString(stream, state) {\n    var next;\n    while ((next = stream.next()) != null) {\n      if (next == '\"' && !stream.eat('\"')) {\n        state.tokenize = null;\n        break;\n      }\n    }\n    return \"string\";\n  }\n\n  // C++11 raw string literal is <prefix>\"<delim>( anything )<delim>\", where\n  // <delim> can be a string up to 16 characters long.\n  function tokenRawString(stream, state) {\n    // Escape characters that have special regex meanings.\n    var delim = state.cpp11RawStringDelim.replace(/[^\\w\\s]/g, '\\\\$&');\n    var match = stream.match(new RegExp(\".*?\\\\)\" + delim + '\"'));\n    if (match)\n      state.tokenize = null;\n    else\n      stream.skipToEnd();\n    return \"string\";\n  }\n\n  function def(mimes, mode) {\n    if (typeof mimes == \"string\") mimes = [mimes];\n    var words = [];\n    function add(obj) {\n      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))\n        words.push(prop);\n    }\n    add(mode.keywords);\n    add(mode.types);\n    add(mode.builtin);\n    add(mode.atoms);\n    if (words.length) {\n      mode.helperType = mimes[0];\n      CodeMirror.registerHelper(\"hintWords\", mimes[0], words);\n    }\n\n    for (var i = 0; i < mimes.length; ++i)\n      CodeMirror.defineMIME(mimes[i], mode);\n  }\n\n  def([\"text/x-csrc\", \"text/x-c\", \"text/x-chdr\"], {\n    name: \"clike\",\n    keywords: words(cKeywords),\n    types: words(cTypes + \" bool _Complex _Bool float_t double_t intptr_t intmax_t \" +\n                 \"int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t \" +\n                 \"uint32_t uint64_t\"),\n    blockKeywords: words(\"case do else for if switch while struct\"),\n    defKeywords: words(\"struct\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"null true false\"),\n    hooks: {\"#\": cppHook, \"*\": pointerHook},\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def([\"text/x-c++src\", \"text/x-c++hdr\"], {\n    name: \"clike\",\n    keywords: words(cKeywords + \" asm dynamic_cast namespace reinterpret_cast try explicit new \" +\n                    \"static_cast typeid catch operator template typename class friend private \" +\n                    \"this using const_cast inline public throw virtual delete mutable protected \" +\n                    \"alignas alignof constexpr decltype nullptr noexcept thread_local final \" +\n                    \"static_assert override\"),\n    types: words(cTypes + \" bool wchar_t\"),\n    blockKeywords: words(\"catch class do else finally for if struct switch try while\"),\n    defKeywords: words(\"class namespace struct enum union\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    dontIndentStatements: /^template$/,\n    isIdentifierChar: /[\\w\\$_~\\xa1-\\uffff]/,\n    hooks: {\n      \"#\": cppHook,\n      \"*\": pointerHook,\n      \"u\": cpp11StringHook,\n      \"U\": cpp11StringHook,\n      \"L\": cpp11StringHook,\n      \"R\": cpp11StringHook,\n      \"0\": cpp14Literal,\n      \"1\": cpp14Literal,\n      \"2\": cpp14Literal,\n      \"3\": cpp14Literal,\n      \"4\": cpp14Literal,\n      \"5\": cpp14Literal,\n      \"6\": cpp14Literal,\n      \"7\": cpp14Literal,\n      \"8\": cpp14Literal,\n      \"9\": cpp14Literal,\n      token: function(stream, state, style) {\n        if (style == \"variable\" && stream.peek() == \"(\" &&\n            (state.prevToken == \";\" || state.prevToken == null ||\n             state.prevToken == \"}\") &&\n            cppLooksLikeConstructor(stream.current()))\n          return \"def\";\n      }\n    },\n    namespaceSeparator: \"::\",\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def(\"text/x-java\", {\n    name: \"clike\",\n    keywords: words(\"abstract assert break case catch class const continue default \" +\n                    \"do else enum extends final finally float for goto if implements import \" +\n                    \"instanceof interface native new package private protected public \" +\n                    \"return static strictfp super switch synchronized this throw throws transient \" +\n                    \"try volatile while @interface\"),\n    types: words(\"byte short int long float double boolean char void Boolean Byte Character Double Float \" +\n                 \"Integer Long Number Object Short String StringBuffer StringBuilder Void\"),\n    blockKeywords: words(\"catch class do else finally for if switch try while\"),\n    defKeywords: words(\"class interface package enum @interface\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+\\.?\\d*|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\n    hooks: {\n      \"@\": function(stream) {\n        // Don't match the @interface keyword.\n        if (stream.match('interface', false)) return false;\n\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    },\n    modeProps: {fold: [\"brace\", \"import\"]}\n  });\n\n  def(\"text/x-csharp\", {\n    name: \"clike\",\n    keywords: words(\"abstract as async await base break case catch checked class const continue\" +\n                    \" default delegate do else enum event explicit extern finally fixed for\" +\n                    \" foreach goto if implicit in interface internal is lock namespace new\" +\n                    \" operator out override params private protected public readonly ref return sealed\" +\n                    \" sizeof stackalloc static struct switch this throw try typeof unchecked\" +\n                    \" unsafe using virtual void volatile while add alias ascending descending dynamic from get\" +\n                    \" global group into join let orderby partial remove select set value var yield\"),\n    types: words(\"Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func\" +\n                 \" Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32\" +\n                 \" UInt64 bool byte char decimal double short int long object\"  +\n                 \" sbyte float string ushort uint ulong\"),\n    blockKeywords: words(\"catch class do else finally for foreach if struct switch try while\"),\n    defKeywords: words(\"class interface namespace struct var\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    hooks: {\n      \"@\": function(stream, state) {\n        if (stream.eat('\"')) {\n          state.tokenize = tokenAtString;\n          return tokenAtString(stream, state);\n        }\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    }\n  });\n\n  function tokenTripleString(stream, state) {\n    var escaped = false;\n    while (!stream.eol()) {\n      if (!escaped && stream.match('\"\"\"')) {\n        state.tokenize = null;\n        break;\n      }\n      escaped = stream.next() == \"\\\\\" && !escaped;\n    }\n    return \"string\";\n  }\n\n  def(\"text/x-scala\", {\n    name: \"clike\",\n    keywords: words(\n\n      /* scala */\n      \"abstract case catch class def do else extends final finally for forSome if \" +\n      \"implicit import lazy match new null object override package private protected return \" +\n      \"sealed super this throw trait try type val var while with yield _ \" +\n\n      /* package scala */\n      \"assert assume require print println printf readLine readBoolean readByte readShort \" +\n      \"readChar readInt readLong readFloat readDouble\"\n    ),\n    types: words(\n      \"AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either \" +\n      \"Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable \" +\n      \"Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering \" +\n      \"Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder \" +\n      \"StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector \" +\n\n      /* package java.lang */\n      \"Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable \" +\n      \"Compiler Double Exception Float Integer Long Math Number Object Package Pair Process \" +\n      \"Runtime Runnable SecurityManager Short StackTraceElement StrictMath String \" +\n      \"StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void\"\n    ),\n    multiLineStrings: true,\n    blockKeywords: words(\"catch class enum do else finally for forSome if match switch try while\"),\n    defKeywords: words(\"class enum def object package trait type val var\"),\n    atoms: words(\"true false null\"),\n    indentStatements: false,\n    indentSwitch: false,\n    isOperatorChar: /[+\\-*&%=<>!?|\\/#:@]/,\n    hooks: {\n      \"@\": function(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      },\n      '\"': function(stream, state) {\n        if (!stream.match('\"\"')) return false;\n        state.tokenize = tokenTripleString;\n        return state.tokenize(stream, state);\n      },\n      \"'\": function(stream) {\n        stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n        return \"atom\";\n      },\n      \"=\": function(stream, state) {\n        var cx = state.context\n        if (cx.type == \"}\" && cx.align && stream.eat(\">\")) {\n          state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev)\n          return \"operator\"\n        } else {\n          return false\n        }\n      }\n    },\n    modeProps: {closeBrackets: {triples: '\"'}}\n  });\n\n  function tokenKotlinString(tripleString){\n    return function (stream, state) {\n      var escaped = false, next, end = false;\n      while (!stream.eol()) {\n        if (!tripleString && !escaped && stream.match('\"') ) {end = true; break;}\n        if (tripleString && stream.match('\"\"\"')) {end = true; break;}\n        next = stream.next();\n        if(!escaped && next == \"$\" && stream.match('{'))\n          stream.skipTo(\"}\");\n        escaped = !escaped && next == \"\\\\\" && !tripleString;\n      }\n      if (end || !tripleString)\n        state.tokenize = null;\n      return \"string\";\n    }\n  }\n\n  def(\"text/x-kotlin\", {\n    name: \"clike\",\n    keywords: words(\n      /*keywords*/\n      \"package as typealias class interface this super val \" +\n      \"var fun for is in This throw return \" +\n      \"break continue object if else while do try when !in !is as? \" +\n\n      /*soft keywords*/\n      \"file import where by get set abstract enum open inner override private public internal \" +\n      \"protected catch finally out final vararg reified dynamic companion constructor init \" +\n      \"sealed field property receiver param sparam lateinit data inline noinline tailrec \" +\n      \"external annotation crossinline const operator infix suspend\"\n    ),\n    types: words(\n      /* package java.lang */\n      \"Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable \" +\n      \"Compiler Double Exception Float Integer Long Math Number Object Package Pair Process \" +\n      \"Runtime Runnable SecurityManager Short StackTraceElement StrictMath String \" +\n      \"StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void\"\n    ),\n    intendSwitch: false,\n    indentStatements: false,\n    multiLineStrings: true,\n    number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+\\.?\\d*|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\n    blockKeywords: words(\"catch class do else finally for if where try while enum\"),\n    defKeywords: words(\"class val var object interface fun\"),\n    atoms: words(\"true false null this\"),\n    hooks: {\n      '\"': function(stream, state) {\n        state.tokenize = tokenKotlinString(stream.match('\"\"'));\n        return state.tokenize(stream, state);\n      }\n    },\n    modeProps: {closeBrackets: {triples: '\"'}}\n  });\n\n  def([\"x-shader/x-vertex\", \"x-shader/x-fragment\"], {\n    name: \"clike\",\n    keywords: words(\"sampler1D sampler2D sampler3D samplerCube \" +\n                    \"sampler1DShadow sampler2DShadow \" +\n                    \"const attribute uniform varying \" +\n                    \"break continue discard return \" +\n                    \"for while do if else struct \" +\n                    \"in out inout\"),\n    types: words(\"float int bool void \" +\n                 \"vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 \" +\n                 \"mat2 mat3 mat4\"),\n    blockKeywords: words(\"for while do if else struct\"),\n    builtin: words(\"radians degrees sin cos tan asin acos atan \" +\n                    \"pow exp log exp2 sqrt inversesqrt \" +\n                    \"abs sign floor ceil fract mod min max clamp mix step smoothstep \" +\n                    \"length distance dot cross normalize ftransform faceforward \" +\n                    \"reflect refract matrixCompMult \" +\n                    \"lessThan lessThanEqual greaterThan greaterThanEqual \" +\n                    \"equal notEqual any all not \" +\n                    \"texture1D texture1DProj texture1DLod texture1DProjLod \" +\n                    \"texture2D texture2DProj texture2DLod texture2DProjLod \" +\n                    \"texture3D texture3DProj texture3DLod texture3DProjLod \" +\n                    \"textureCube textureCubeLod \" +\n                    \"shadow1D shadow2D shadow1DProj shadow2DProj \" +\n                    \"shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod \" +\n                    \"dFdx dFdy fwidth \" +\n                    \"noise1 noise2 noise3 noise4\"),\n    atoms: words(\"true false \" +\n                \"gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex \" +\n                \"gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 \" +\n                \"gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 \" +\n                \"gl_FogCoord gl_PointCoord \" +\n                \"gl_Position gl_PointSize gl_ClipVertex \" +\n                \"gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor \" +\n                \"gl_TexCoord gl_FogFragCoord \" +\n                \"gl_FragCoord gl_FrontFacing \" +\n                \"gl_FragData gl_FragDepth \" +\n                \"gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix \" +\n                \"gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse \" +\n                \"gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse \" +\n                \"gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose \" +\n                \"gl_ProjectionMatrixInverseTranspose \" +\n                \"gl_ModelViewProjectionMatrixInverseTranspose \" +\n                \"gl_TextureMatrixInverseTranspose \" +\n                \"gl_NormalScale gl_DepthRange gl_ClipPlane \" +\n                \"gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel \" +\n                \"gl_FrontLightModelProduct gl_BackLightModelProduct \" +\n                \"gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ \" +\n                \"gl_FogParameters \" +\n                \"gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords \" +\n                \"gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats \" +\n                \"gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits \" +\n                \"gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits \" +\n                \"gl_MaxDrawBuffers\"),\n    indentSwitch: false,\n    hooks: {\"#\": cppHook},\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def(\"text/x-nesc\", {\n    name: \"clike\",\n    keywords: words(cKeywords + \"as atomic async call command component components configuration event generic \" +\n                    \"implementation includes interface module new norace nx_struct nx_union post provides \" +\n                    \"signal task uses abstract extends\"),\n    types: words(cTypes),\n    blockKeywords: words(\"case do else for if switch while struct\"),\n    atoms: words(\"null true false\"),\n    hooks: {\"#\": cppHook},\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  def(\"text/x-objectivec\", {\n    name: \"clike\",\n    keywords: words(cKeywords + \"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in \" +\n                    \"inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly\"),\n    types: words(cTypes),\n    atoms: words(\"YES NO NULL NILL ON OFF true false\"),\n    hooks: {\n      \"@\": function(stream) {\n        stream.eatWhile(/[\\w\\$]/);\n        return \"keyword\";\n      },\n      \"#\": cppHook,\n      indent: function(_state, ctx, textAfter) {\n        if (ctx.type == \"statement\" && /^@\\w/.test(textAfter)) return ctx.indented\n      }\n    },\n    modeProps: {fold: \"brace\"}\n  });\n\n  def(\"text/x-squirrel\", {\n    name: \"clike\",\n    keywords: words(\"base break clone continue const default delete enum extends function in class\" +\n                    \" foreach local resume return this throw typeof yield constructor instanceof static\"),\n    types: words(cTypes),\n    blockKeywords: words(\"case catch class else for foreach if switch try while\"),\n    defKeywords: words(\"function local class\"),\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null\"),\n    hooks: {\"#\": cppHook},\n    modeProps: {fold: [\"brace\", \"include\"]}\n  });\n\n  // Ceylon Strings need to deal with interpolation\n  var stringTokenizer = null;\n  function tokenCeylonString(type) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while (!stream.eol()) {\n        if (!escaped && stream.match('\"') &&\n              (type == \"single\" || stream.match('\"\"'))) {\n          end = true;\n          break;\n        }\n        if (!escaped && stream.match('``')) {\n          stringTokenizer = tokenCeylonString(type);\n          end = true;\n          break;\n        }\n        next = stream.next();\n        escaped = type == \"single\" && !escaped && next == \"\\\\\";\n      }\n      if (end)\n          state.tokenize = null;\n      return \"string\";\n    }\n  }\n\n  def(\"text/x-ceylon\", {\n    name: \"clike\",\n    keywords: words(\"abstracts alias assembly assert assign break case catch class continue dynamic else\" +\n                    \" exists extends finally for function given if import in interface is let module new\" +\n                    \" nonempty object of out outer package return satisfies super switch then this throw\" +\n                    \" try value void while\"),\n    types: function(word) {\n        // In Ceylon all identifiers that start with an uppercase are types\n        var first = word.charAt(0);\n        return (first === first.toUpperCase() && first !== first.toLowerCase());\n    },\n    blockKeywords: words(\"case catch class dynamic else finally for function if interface module new object switch try while\"),\n    defKeywords: words(\"class dynamic function interface module object package value\"),\n    builtin: words(\"abstract actual aliased annotation by default deprecated doc final formal late license\" +\n                   \" native optional sealed see serializable shared suppressWarnings tagged throws variable\"),\n    isPunctuationChar: /[\\[\\]{}\\(\\),;\\:\\.`]/,\n    isOperatorChar: /[+\\-*&%=<>!?|^~:\\/]/,\n    numberStart: /[\\d#$]/,\n    number: /^(?:#[\\da-fA-F_]+|\\$[01_]+|[\\d_]+[kMGTPmunpf]?|[\\d_]+\\.[\\d_]+(?:[eE][-+]?\\d+|[kMGTPmunpf]|)|)/i,\n    multiLineStrings: true,\n    typeFirstDefinitions: true,\n    atoms: words(\"true false null larger smaller equal empty finished\"),\n    indentSwitch: false,\n    styleDefs: false,\n    hooks: {\n      \"@\": function(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      },\n      '\"': function(stream, state) {\n          state.tokenize = tokenCeylonString(stream.match('\"\"') ? \"triple\" : \"single\");\n          return state.tokenize(stream, state);\n        },\n      '`': function(stream, state) {\n          if (!stringTokenizer || !stream.match('`')) return false;\n          state.tokenize = stringTokenizer;\n          stringTokenizer = null;\n          return state.tokenize(stream, state);\n        },\n      \"'\": function(stream) {\n        stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n        return \"atom\";\n      },\n      token: function(_stream, state, style) {\n          if ((style == \"variable\" || style == \"type\") &&\n              state.prevToken == \".\") {\n            return \"variable-2\";\n          }\n        }\n    },\n    modeProps: {\n        fold: [\"brace\", \"import\"],\n        closeBrackets: {triples: '\"'}\n    }\n  });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/clike/clike.js\n// module id = 5\n// module chunks = 0","/// <reference path=\"./globals.d.ts\" />\n\n// This doesn't import all of CodeMirror, instead it only imports\n// a small subset. This hack is brought to you by webpack and you\n// can read all about it in webpack.common.js.\nimport {\n  getMode,\n  innerMode,\n  StringStream,\n} from 'codemirror/addon/runmode/runmode.node.js'\n\nimport { ITokens, IHighlightRequest } from '../lib/highlighter/types'\n\nconst extensionMIMEMap = new Map<string, string>()\n\nimport 'codemirror/mode/javascript/javascript'\n\nextensionMIMEMap.set('.ts', 'text/typescript')\nextensionMIMEMap.set('.js', 'text/javascript')\nextensionMIMEMap.set('.json', 'application/json')\n\nimport 'codemirror/mode/jsx/jsx'\nextensionMIMEMap.set('.tsx', 'text/typescript-jsx')\nextensionMIMEMap.set('.jsx', 'text/jsx')\n\nimport 'codemirror/mode/htmlmixed/htmlmixed'\nextensionMIMEMap.set('.html', 'text/html')\nextensionMIMEMap.set('.htm', 'text/html')\n\nimport 'codemirror/mode/css/css'\nextensionMIMEMap.set('.css', 'text/css')\nextensionMIMEMap.set('.scss', 'text/x-scss')\nextensionMIMEMap.set('.less', 'text/x-less')\n\nimport 'codemirror/mode/markdown/markdown'\nextensionMIMEMap.set('.markdown', 'text/x-markdown')\nextensionMIMEMap.set('.md', 'text/x-markdown')\n\nimport 'codemirror/mode/yaml/yaml'\nextensionMIMEMap.set('.yaml', 'text/yaml')\nextensionMIMEMap.set('.yml', 'text/yaml')\n\nimport 'codemirror/mode/xml/xml'\nextensionMIMEMap.set('.xml', 'text/xml')\nextensionMIMEMap.set('.xaml', 'text/xml')\nextensionMIMEMap.set('.csproj', 'text/xml')\nextensionMIMEMap.set('.svg', 'text/xml')\n\nimport 'codemirror/mode/clike/clike'\nextensionMIMEMap.set('.objc', 'text/x-objectivec')\nextensionMIMEMap.set('.scala', 'text/x-scala')\nextensionMIMEMap.set('.sc', 'text/x-scala')\nextensionMIMEMap.set('.cs', 'text/x-csharp')\nextensionMIMEMap.set('.java', 'text/x-java')\nextensionMIMEMap.set('.c', 'text/x-c')\nextensionMIMEMap.set('.h', 'text/x-c')\nextensionMIMEMap.set('.cpp', 'text/x-c++src')\n\nimport 'codemirror/mode/shell/shell'\nextensionMIMEMap.set('.sh', 'text/x-sh')\n\nimport 'codemirror/mode/go/go'\nextensionMIMEMap.set('.go', 'text/x-go')\n\nimport 'codemirror/mode/perl/perl'\nextensionMIMEMap.set('.pl', 'text/x-perl')\n\nimport 'codemirror/mode/php/php'\nextensionMIMEMap.set('.php', 'application/x-httpd-php')\n\nimport 'codemirror/mode/python/python'\nextensionMIMEMap.set('.py', 'text/x-python')\n\nimport 'codemirror/mode/ruby/ruby'\nextensionMIMEMap.set('.rb', 'text/x-ruby')\n\nfunction guessMimeType(contents: string) {\n  if (contents.startsWith('<?xml')) {\n    return 'text/xml'\n  }\n\n  if (contents.startsWith('#!')) {\n    const m = /^#!.*?(ts-node|node|bash|sh|python(?:[\\d.]+)?)\\r?\\n/g.exec(\n      contents\n    )\n\n    if (m) {\n      switch (m[1]) {\n        case 'ts-node':\n          return 'text/typescript'\n        case 'node':\n          return 'text/javascript'\n        case 'sh':\n        case 'bash':\n          return 'text/x-sh'\n        case 'perl':\n          return 'text/x-perl'\n      }\n\n      if (m[1].startsWith('python')) {\n        return 'text/x-python'\n      }\n    }\n  }\n\n  return null\n}\n\nfunction detectMode(request: IHighlightRequest): CodeMirror.Mode<{}> | null {\n  const mimeType =\n    extensionMIMEMap.get(request.extension) || guessMimeType(request.contents)\n\n  if (!mimeType) {\n    return null\n  }\n\n  return getMode({}, mimeType) || null\n}\n\nfunction getModeName(mode: CodeMirror.Mode<{}>): string | null {\n  const name = (mode as any).name\n  return name && typeof name === 'string' ? name : null\n}\n\n/**\n * Helper method to determine the name of the innermost (i.e. current)\n * mode. Think of this as an abstraction over CodeMirror's innerMode\n * with added type guards.\n */\nfunction getInnerModeName(\n  mode: CodeMirror.Mode<{}>,\n  state: any\n): string | null {\n  const inner = innerMode(mode, state)\n  return inner && inner.mode ? getModeName(inner.mode) : null\n}\n\n/**\n * Extract the next token from the line stream or null if no token\n * could be extracted from the current position in the line stream.\n *\n * This method is more or less equal to the readToken method in\n * CodeMirror but since the readToken class in CodeMirror isn't included\n * in the Node runmode we're not able to use it.\n *\n * Worth noting here is that we're also replicated the workaround for\n * modes that aren't adhering to the rules of never returning without\n * advancing the line stream by trying it again (up to ten times). See\n * https://github.com/codemirror/CodeMirror/commit/2c60a2 for more\n * details on that.\n *\n * @param mode         The current (outer) mode\n * @param stream       The StringStream for the current line\n * @param state        The current mode state (if any)\n * @param addModeClass Whether or not to append the current (inner) mode name\n *                     as an extra CSS clas to the token, indicating the mode\n *                     that produced it, prefixed with \"cm-m-\". For example,\n *                     tokens from the XML mode will get the cm-m-xml class.\n */\nfunction readToken(\n  mode: CodeMirror.Mode<{}>,\n  stream: StringStream,\n  state: any,\n  addModeClass: boolean\n): string | null {\n  for (let i = 0; i < 10; i++) {\n    const innerModeName = addModeClass ? getInnerModeName(mode, state) : null\n    const token = mode.token(stream, state)\n\n    if (stream.pos > stream.start) {\n      return token && innerModeName ? `m-${innerModeName} ${token}` : token\n    }\n  }\n\n  throw new Error(`Mode ${getModeName(mode)} failed to advance stream.`)\n}\n\nonmessage = (ev: MessageEvent) => {\n  const request = ev.data as IHighlightRequest\n\n  const tabSize = request.tabSize || 4\n  const contents = request.contents\n  const addModeClass = request.addModeClass === true\n\n  const mode = detectMode(request)\n\n  if (!mode) {\n    postMessage({})\n    return\n  }\n\n  const lineFilter =\n    request.lines && request.lines.length\n      ? new Set<number>(request.lines)\n      : null\n\n  // If we've got a set of requested lines we can keep track of the maximum\n  // line we need so that we can bail immediately when we've reached it.\n  const maxLine = lineFilter ? Math.max(...lineFilter) : null\n\n  const lines = contents.split(/\\r?\\n/)\n  const state: any = mode.startState ? mode.startState() : null\n\n  const tokens: ITokens = {}\n\n  for (const [ix, line] of lines.entries()) {\n    // No need to continue after the max line\n    if (maxLine !== null && ix > maxLine) {\n      break\n    }\n\n    // For stateless modes we can optimize by only running\n    // the tokenizer over lines we care about.\n    if (lineFilter && !state) {\n      if (!lineFilter.has(ix)) {\n        continue\n      }\n    }\n\n    if (!line.length) {\n      if (mode.blankLine) {\n        mode.blankLine(state)\n      }\n\n      continue\n    }\n\n    const lineCtx = { lines, line: ix }\n    const lineStream = new StringStream(line, tabSize, lineCtx)\n\n    while (!lineStream.eol()) {\n      const token = readToken(mode, lineStream, state, addModeClass)\n\n      if (token && (!lineFilter || lineFilter.has(ix))) {\n        tokens[ix] = tokens[ix] || {}\n        tokens[ix][lineStream.start] = {\n          length: lineStream.pos - lineStream.start,\n          token,\n        }\n      }\n\n      lineStream.start = lineStream.pos\n    }\n  }\n\n  postMessage(tokens)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/highlighter/index.ts","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../javascript/javascript\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n\n  // Depth means the amount of open braces in JS context, in XML\n  // context 0 means not in tag, 1 means in tag, and 2 means in tag\n  // and js block comment.\n  function Context(state, mode, depth, prev) {\n    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev\n  }\n\n  function copyContext(context) {\n    return new Context(CodeMirror.copyState(context.mode, context.state),\n                       context.mode,\n                       context.depth,\n                       context.prev && copyContext(context.prev))\n  }\n\n  CodeMirror.defineMode(\"jsx\", function(config, modeConfig) {\n    var xmlMode = CodeMirror.getMode(config, {name: \"xml\", allowMissing: true, multilineTagIndentPastTag: false})\n    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || \"javascript\")\n\n    function flatXMLIndent(state) {\n      var tagName = state.tagName\n      state.tagName = null\n      var result = xmlMode.indent(state, \"\")\n      state.tagName = tagName\n      return result\n    }\n\n    function token(stream, state) {\n      if (state.context.mode == xmlMode)\n        return xmlToken(stream, state, state.context)\n      else\n        return jsToken(stream, state, state.context)\n    }\n\n    function xmlToken(stream, state, cx) {\n      if (cx.depth == 2) { // Inside a JS /* */ comment\n        if (stream.match(/^.*?\\*\\//)) cx.depth = 1\n        else stream.skipToEnd()\n        return \"comment\"\n      }\n\n      if (stream.peek() == \"{\") {\n        xmlMode.skipAttribute(cx.state)\n\n        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context\n        // If JS starts on same line as tag\n        if (xmlContext && stream.match(/^[^>]*>\\s*$/, false)) {\n          while (xmlContext.prev && !xmlContext.startOfLine)\n            xmlContext = xmlContext.prev\n          // If tag starts the line, use XML indentation level\n          if (xmlContext.startOfLine) indent -= config.indentUnit\n          // Else use JS indentation level\n          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented\n        // Else if inside of tag\n        } else if (cx.depth == 1) {\n          indent += config.indentUnit\n        }\n\n        state.context = new Context(CodeMirror.startState(jsMode, indent),\n                                    jsMode, 0, state.context)\n        return null\n      }\n\n      if (cx.depth == 1) { // Inside of tag\n        if (stream.peek() == \"<\") { // Tag inside of tag\n          xmlMode.skipAttribute(cx.state)\n          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),\n                                      xmlMode, 0, state.context)\n          return null\n        } else if (stream.match(\"//\")) {\n          stream.skipToEnd()\n          return \"comment\"\n        } else if (stream.match(\"/*\")) {\n          cx.depth = 2\n          return token(stream, state)\n        }\n      }\n\n      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop\n      if (/\\btag\\b/.test(style)) {\n        if (/>$/.test(cur)) {\n          if (cx.state.context) cx.depth = 0\n          else state.context = state.context.prev\n        } else if (/^</.test(cur)) {\n          cx.depth = 1\n        }\n      } else if (!style && (stop = cur.indexOf(\"{\")) > -1) {\n        stream.backUp(cur.length - stop)\n      }\n      return style\n    }\n\n    function jsToken(stream, state, cx) {\n      if (stream.peek() == \"<\" && jsMode.expressionAllowed(stream, cx.state)) {\n        jsMode.skipExpression(cx.state)\n        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, \"\")),\n                                    xmlMode, 0, state.context)\n        return null\n      }\n\n      var style = jsMode.token(stream, cx.state)\n      if (!style && cx.depth != null) {\n        var cur = stream.current()\n        if (cur == \"{\") {\n          cx.depth++\n        } else if (cur == \"}\") {\n          if (--cx.depth == 0) state.context = state.context.prev\n        }\n      }\n      return style\n    }\n\n    return {\n      startState: function() {\n        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}\n      },\n\n      copyState: function(state) {\n        return {context: copyContext(state.context)}\n      },\n\n      token: token,\n\n      indent: function(state, textAfter, fullLine) {\n        return state.context.mode.indent(state.context.state, textAfter, fullLine)\n      },\n\n      innerMode: function(state) {\n        return state.context\n      }\n    }\n  }, \"xml\", \"javascript\")\n\n  CodeMirror.defineMIME(\"text/jsx\", \"jsx\")\n  CodeMirror.defineMIME(\"text/typescript-jsx\", {name: \"jsx\", base: {name: \"javascript\", typescript: true}})\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/jsx/jsx.js\n// module id = 7\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../meta\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../meta\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\n\n  var htmlMode = CodeMirror.getMode(cmCfg, \"text/html\");\n  var htmlModeMissing = htmlMode.name == \"null\"\n\n  function getMode(name) {\n    if (CodeMirror.findModeByName) {\n      var found = CodeMirror.findModeByName(name);\n      if (found) name = found.mime || found.mimes[0];\n    }\n    var mode = CodeMirror.getMode(cmCfg, name);\n    return mode.name == \"null\" ? null : mode;\n  }\n\n  // Should characters that affect highlighting be highlighted separate?\n  // Does not include characters that will be output (such as `1.` and `-` for lists)\n  if (modeCfg.highlightFormatting === undefined)\n    modeCfg.highlightFormatting = false;\n\n  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\n  // Excess `>` will emit `error` token.\n  if (modeCfg.maxBlockquoteDepth === undefined)\n    modeCfg.maxBlockquoteDepth = 0;\n\n  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\n  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\n\n  // Turn on strikethrough syntax\n  if (modeCfg.strikethrough === undefined)\n    modeCfg.strikethrough = false;\n\n  if (modeCfg.emoji === undefined)\n    modeCfg.emoji = false;\n\n  if (modeCfg.fencedCodeBlockHighlighting === undefined)\n    modeCfg.fencedCodeBlockHighlighting = true;\n\n  if (modeCfg.xml === undefined)\n    modeCfg.xml = true;\n\n  // Allow token types to be overridden by user-provided token types.\n  if (modeCfg.tokenTypeOverrides === undefined)\n    modeCfg.tokenTypeOverrides = {};\n\n  var tokenTypes = {\n    header: \"header\",\n    code: \"comment\",\n    quote: \"quote\",\n    list1: \"variable-2\",\n    list2: \"variable-3\",\n    list3: \"keyword\",\n    hr: \"hr\",\n    image: \"image\",\n    imageAltText: \"image-alt-text\",\n    imageMarker: \"image-marker\",\n    formatting: \"formatting\",\n    linkInline: \"link\",\n    linkEmail: \"link\",\n    linkText: \"link\",\n    linkHref: \"string\",\n    em: \"em\",\n    strong: \"strong\",\n    strikethrough: \"strikethrough\",\n    emoji: \"builtin\"\n  };\n\n  for (var tokenType in tokenTypes) {\n    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\n      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\n    }\n  }\n\n  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\n  ,   listRE = /^(?:[*\\-+]|^[0-9]+([.)]))\\s+/\n  ,   taskListRE = /^\\[(x| )\\](?=\\s)/i // Must follow listRE\n  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\n  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\n  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~:]+/\n  ,   fencedCodeRE = /^(~~~+|```+)[ \\t]*([\\w+#-]*)[^\\n`]*$/\n  ,   linkDefRE = /^\\s*\\[[^\\]]+?\\]:\\s*\\S+(\\s*\\S*\\s*)?$/ // naive link-definition\n  ,   punctuation = /[!\\\"#$%&\\'()*+,\\-\\.\\/:;<=>?@\\[\\\\\\]^_`{|}~]/\n  ,   expandedTab = \"    \" // CommonMark specifies tab as 4 spaces\n\n  function switchInline(stream, state, f) {\n    state.f = state.inline = f;\n    return f(stream, state);\n  }\n\n  function switchBlock(stream, state, f) {\n    state.f = state.block = f;\n    return f(stream, state);\n  }\n\n  function lineIsEmpty(line) {\n    return !line || !/\\S/.test(line.string)\n  }\n\n  // Blocks\n\n  function blankLine(state) {\n    // Reset linkTitle state\n    state.linkTitle = false;\n    // Reset EM state\n    state.em = false;\n    // Reset STRONG state\n    state.strong = false;\n    // Reset strikethrough state\n    state.strikethrough = false;\n    // Reset state.quote\n    state.quote = 0;\n    // Reset state.indentedCode\n    state.indentedCode = false;\n    if (state.f == htmlBlock) {\n      state.f = inlineNormal;\n      state.block = blockNormal;\n    }\n    // Reset state.trailingSpace\n    state.trailingSpace = 0;\n    state.trailingSpaceNewLine = false;\n    // Mark this line as blank\n    state.prevLine = state.thisLine\n    state.thisLine = {stream: null}\n    return null;\n  }\n\n  function blockNormal(stream, state) {\n    var firstTokenOnLine = stream.column() === state.indentation;\n    var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);\n    var prevLineIsIndentedCode = state.indentedCode;\n    var prevLineIsHr = state.prevLine.hr;\n    var prevLineIsList = state.list !== false;\n    var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;\n\n    state.indentedCode = false;\n\n    var lineIndentation = state.indentation;\n    // compute once per line (on first token)\n    if (state.indentationDiff === null) {\n      state.indentationDiff = state.indentation;\n      if (prevLineIsList) {\n        state.list = null;\n        // While this list item's marker's indentation is less than the deepest\n        //  list item's content's indentation,pop the deepest list item\n        //  indentation off the stack, and update block indentation state\n        while (lineIndentation < state.listStack[state.listStack.length - 1]) {\n          state.listStack.pop();\n          if (state.listStack.length) {\n            state.indentation = state.listStack[state.listStack.length - 1];\n          // less than the first list's indent -> the line is no longer a list\n          } else {\n            state.list = false;\n          }\n        }\n        if (state.list !== false) {\n          state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1]\n        }\n      }\n    }\n\n    // not comprehensive (currently only for setext detection purposes)\n    var allowsInlineContinuation = (\n        !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header &&\n        (!prevLineIsList || !prevLineIsIndentedCode) &&\n        !state.prevLine.fencedCodeEnd\n    );\n\n    var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) &&\n      state.indentation <= maxNonCodeIndentation && stream.match(hrRE);\n\n    var match = null;\n    if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd ||\n         state.prevLine.header || prevLineLineIsEmpty)) {\n      stream.skipToEnd();\n      state.indentedCode = true;\n      return tokenTypes.code;\n    } else if (stream.eatSpace()) {\n      return null;\n    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\n      state.quote = 0;\n      state.header = match[1].length;\n      state.thisLine.header = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      state.f = state.inline;\n      return getType(state);\n    } else if (state.indentation <= maxNonCodeIndentation && stream.eat('>')) {\n      state.quote = firstTokenOnLine ? 1 : state.quote + 1;\n      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\n      stream.eatSpace();\n      return getType(state);\n    } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {\n      var listType = match[1] ? \"ol\" : \"ul\";\n\n      state.indentation = lineIndentation + stream.current().length;\n      state.list = true;\n      state.quote = 0;\n\n      // Add this list item's content's indentation to the stack\n      state.listStack.push(state.indentation);\n\n      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\n        state.taskList = true;\n      }\n      state.f = state.inline;\n      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\n      return getType(state);\n    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {\n      state.quote = 0;\n      state.fencedEndRE = new RegExp(match[1] + \"+ *$\");\n      // try switching mode\n      state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2]);\n      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);\n      state.f = state.block = local;\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n      state.code = -1\n      return getType(state);\n    // SETEXT has lowest block-scope precedence after HR, so check it after\n    //  the others (code, blockquote, list...)\n    } else if (\n      // if setext set, indicates line after ---/===\n      state.setext || (\n        // line before ---/===\n        (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false &&\n        !state.code && !isHr && !linkDefRE.test(stream.string) &&\n        (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))\n      )\n    ) {\n      if ( !state.setext ) {\n        state.header = match[0].charAt(0) == '=' ? 1 : 2;\n        state.setext = state.header;\n      } else {\n        state.header = state.setext;\n        // has no effect on type so we can reset it now\n        state.setext = 0;\n        stream.skipToEnd();\n        if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      }\n      state.thisLine.header = true;\n      state.f = state.inline;\n      return getType(state);\n    } else if (isHr) {\n      stream.skipToEnd();\n      state.hr = true;\n      state.thisLine.hr = true;\n      return tokenTypes.hr;\n    } else if (stream.peek() === '[') {\n      return switchInline(stream, state, footnoteLink);\n    }\n\n    return switchInline(stream, state, state.inline);\n  }\n\n  function htmlBlock(stream, state) {\n    var style = htmlMode.token(stream, state.htmlState);\n    if (!htmlModeMissing) {\n      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)\n      if ((inner.mode.name == \"xml\" && inner.state.tagStart === null &&\n           (!inner.state.context && inner.state.tokenize.isInText)) ||\n          (state.md_inside && stream.current().indexOf(\">\") > -1)) {\n        state.f = inlineNormal;\n        state.block = blockNormal;\n        state.htmlState = null;\n      }\n    }\n    return style;\n  }\n\n  function local(stream, state) {\n    var currListInd = state.listStack[state.listStack.length - 1] || 0;\n    var hasExitedList = state.indentation < currListInd;\n    var maxFencedEndInd = currListInd + 3;\n    if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n      var returnType;\n      if (!hasExitedList) returnType = getType(state)\n      state.localMode = state.localState = null;\n      state.block = blockNormal;\n      state.f = inlineNormal;\n      state.fencedEndRE = null;\n      state.code = 0\n      state.thisLine.fencedCodeEnd = true;\n      if (hasExitedList) return switchBlock(stream, state, state.block);\n      return returnType;\n    } else if (state.localMode) {\n      return state.localMode.token(stream, state.localState);\n    } else {\n      stream.skipToEnd();\n      return tokenTypes.code;\n    }\n  }\n\n  // Inline\n  function getType(state) {\n    var styles = [];\n\n    if (state.formatting) {\n      styles.push(tokenTypes.formatting);\n\n      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\n\n      for (var i = 0; i < state.formatting.length; i++) {\n        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\n\n        if (state.formatting[i] === \"header\") {\n          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\n        }\n\n        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\n        // Add `error` instead if the maximum blockquote nesting depth is passed\n        if (state.formatting[i] === \"quote\") {\n          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\n          } else {\n            styles.push(\"error\");\n          }\n        }\n      }\n    }\n\n    if (state.taskOpen) {\n      styles.push(\"meta\");\n      return styles.length ? styles.join(' ') : null;\n    }\n    if (state.taskClosed) {\n      styles.push(\"property\");\n      return styles.length ? styles.join(' ') : null;\n    }\n\n    if (state.linkHref) {\n      styles.push(tokenTypes.linkHref, \"url\");\n    } else { // Only apply inline styles to non-url text\n      if (state.strong) { styles.push(tokenTypes.strong); }\n      if (state.em) { styles.push(tokenTypes.em); }\n      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\n      if (state.emoji) { styles.push(tokenTypes.emoji); }\n      if (state.linkText) { styles.push(tokenTypes.linkText); }\n      if (state.code) { styles.push(tokenTypes.code); }\n      if (state.image) { styles.push(tokenTypes.image); }\n      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, \"link\"); }\n      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }\n    }\n\n    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\n\n    if (state.quote) {\n      styles.push(tokenTypes.quote);\n\n      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\n      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n        styles.push(tokenTypes.quote + \"-\" + state.quote);\n      } else {\n        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\n      }\n    }\n\n    if (state.list !== false) {\n      var listMod = (state.listStack.length - 1) % 3;\n      if (!listMod) {\n        styles.push(tokenTypes.list1);\n      } else if (listMod === 1) {\n        styles.push(tokenTypes.list2);\n      } else {\n        styles.push(tokenTypes.list3);\n      }\n    }\n\n    if (state.trailingSpaceNewLine) {\n      styles.push(\"trailing-space-new-line\");\n    } else if (state.trailingSpace) {\n      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\n    }\n\n    return styles.length ? styles.join(' ') : null;\n  }\n\n  function handleText(stream, state) {\n    if (stream.match(textRE, true)) {\n      return getType(state);\n    }\n    return undefined;\n  }\n\n  function inlineNormal(stream, state) {\n    var style = state.text(stream, state);\n    if (typeof style !== 'undefined')\n      return style;\n\n    if (state.list) { // List marker (*, +, -, 1., etc)\n      state.list = null;\n      return getType(state);\n    }\n\n    if (state.taskList) {\n      var taskOpen = stream.match(taskListRE, true)[1] === \" \";\n      if (taskOpen) state.taskOpen = true;\n      else state.taskClosed = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"task\";\n      state.taskList = false;\n      return getType(state);\n    }\n\n    state.taskOpen = false;\n    state.taskClosed = false;\n\n    if (state.header && stream.match(/^#+$/, true)) {\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      return getType(state);\n    }\n\n    var ch = stream.next();\n\n    // Matches link titles present on next line\n    if (state.linkTitle) {\n      state.linkTitle = false;\n      var matchCh = ch;\n      if (ch === '(') {\n        matchCh = ')';\n      }\n      matchCh = (matchCh+'').replace(/([.?*+^\\[\\]\\\\(){}|-])/g, \"\\\\$1\");\n      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\n      if (stream.match(new RegExp(regex), true)) {\n        return tokenTypes.linkHref;\n      }\n    }\n\n    // If this block is changed, it may need to be updated in GFM mode\n    if (ch === '`') {\n      var previousFormatting = state.formatting;\n      if (modeCfg.highlightFormatting) state.formatting = \"code\";\n      stream.eatWhile('`');\n      var count = stream.current().length\n      if (state.code == 0 && (!state.quote || count == 1)) {\n        state.code = count\n        return getType(state)\n      } else if (count == state.code) { // Must be exact\n        var t = getType(state)\n        state.code = 0\n        return t\n      } else {\n        state.formatting = previousFormatting\n        return getType(state)\n      }\n    } else if (state.code) {\n      return getType(state);\n    }\n\n    if (ch === '\\\\') {\n      stream.next();\n      if (modeCfg.highlightFormatting) {\n        var type = getType(state);\n        var formattingEscape = tokenTypes.formatting + \"-escape\";\n        return type ? type + \" \" + formattingEscape : formattingEscape;\n      }\n    }\n\n    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\n      state.imageMarker = true;\n      state.image = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\n      return getType(state);\n    }\n\n    if (ch === '[' && state.imageMarker && stream.match(/[^\\]]*\\](\\(.*?\\)| ?\\[.*?\\])/, false)) {\n      state.imageMarker = false;\n      state.imageAltText = true\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\n      return getType(state);\n    }\n\n    if (ch === ']' && state.imageAltText) {\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\n      var type = getType(state);\n      state.imageAltText = false;\n      state.image = false;\n      state.inline = state.f = linkHref;\n      return type;\n    }\n\n    if (ch === '[' && !state.image) {\n      state.linkText = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      return getType(state);\n    }\n\n    if (ch === ']' && state.linkText) {\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      state.linkText = false;\n      state.inline = state.f = stream.match(/\\(.*?\\)| ?\\[.*?\\]/, false) ? linkHref : inlineNormal\n      return type;\n    }\n\n    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\n      state.f = state.inline = linkInline;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkInline;\n    }\n\n    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\n      state.f = state.inline = linkInline;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkEmail;\n    }\n\n    if (modeCfg.xml && ch === '<' && stream.match(/^(!--|[a-z]+(?:\\s+[a-z_:.\\-]+(?:\\s*=\\s*[^ >]+)?)*\\s*>)/i, false)) {\n      var end = stream.string.indexOf(\">\", stream.pos);\n      if (end != -1) {\n        var atts = stream.string.substring(stream.start, end);\n        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\n      }\n      stream.backUp(1);\n      state.htmlState = CodeMirror.startState(htmlMode);\n      return switchBlock(stream, state, htmlBlock);\n    }\n\n    if (modeCfg.xml && ch === '<' && stream.match(/^\\/\\w*?>/)) {\n      state.md_inside = false;\n      return \"tag\";\n    } else if (ch === \"*\" || ch === \"_\") {\n      var len = 1, before = stream.pos == 1 ? \" \" : stream.string.charAt(stream.pos - 2)\n      while (len < 3 && stream.eat(ch)) len++\n      var after = stream.peek() || \" \"\n      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis\n      var leftFlanking = !/\\s/.test(after) && (!punctuation.test(after) || /\\s/.test(before) || punctuation.test(before))\n      var rightFlanking = !/\\s/.test(before) && (!punctuation.test(before) || /\\s/.test(after) || punctuation.test(after))\n      var setEm = null, setStrong = null\n      if (len % 2) { // Em\n        if (!state.em && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\n          setEm = true\n        else if (state.em == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\n          setEm = false\n      }\n      if (len > 1) { // Strong\n        if (!state.strong && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\n          setStrong = true\n        else if (state.strong == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\n          setStrong = false\n      }\n      if (setStrong != null || setEm != null) {\n        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? \"strong\" : setStrong == null ? \"em\" : \"strong em\"\n        if (setEm === true) state.em = ch\n        if (setStrong === true) state.strong = ch\n        var t = getType(state)\n        if (setEm === false) state.em = false\n        if (setStrong === false) state.strong = false\n        return t\n      }\n    } else if (ch === ' ') {\n      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\n        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n          return getType(state);\n        } else { // Not surrounded by spaces, back up pointer\n          stream.backUp(1);\n        }\n      }\n    }\n\n    if (modeCfg.strikethrough) {\n      if (ch === '~' && stream.eatWhile(ch)) {\n        if (state.strikethrough) {// Remove strikethrough\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n          var t = getType(state);\n          state.strikethrough = false;\n          return t;\n        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\n          state.strikethrough = true;\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n          return getType(state);\n        }\n      } else if (ch === ' ') {\n        if (stream.match(/^~~/, true)) { // Probably surrounded by space\n          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n            return getType(state);\n          } else { // Not surrounded by spaces, back up pointer\n            stream.backUp(2);\n          }\n        }\n      }\n    }\n\n    if (modeCfg.emoji && ch === \":\" && stream.match(/^[a-z_\\d+-]+:/)) {\n      state.emoji = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"emoji\";\n      var retType = getType(state);\n      state.emoji = false;\n      return retType;\n    }\n\n    if (ch === ' ') {\n      if (stream.match(/ +$/, false)) {\n        state.trailingSpace++;\n      } else if (state.trailingSpace) {\n        state.trailingSpaceNewLine = true;\n      }\n    }\n\n    return getType(state);\n  }\n\n  function linkInline(stream, state) {\n    var ch = stream.next();\n\n    if (ch === \">\") {\n      state.f = state.inline = inlineNormal;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkInline;\n    }\n\n    stream.match(/^[^>]+/, true);\n\n    return tokenTypes.linkInline;\n  }\n\n  function linkHref(stream, state) {\n    // Check if space, and return NULL if so (to avoid marking the space)\n    if(stream.eatSpace()){\n      return null;\n    }\n    var ch = stream.next();\n    if (ch === '(' || ch === '[') {\n      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\n      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n      state.linkHref = true;\n      return getType(state);\n    }\n    return 'error';\n  }\n\n  var linkRE = {\n    \")\": /^(?:[^\\\\\\(\\)]|\\\\.|\\((?:[^\\\\\\(\\)]|\\\\.)*\\))*?(?=\\))/,\n    \"]\": /^(?:[^\\\\\\[\\]]|\\\\.|\\[(?:[^\\\\\\[\\]]|\\\\.)*\\])*?(?=\\])/\n  }\n\n  function getLinkHrefInside(endChar) {\n    return function(stream, state) {\n      var ch = stream.next();\n\n      if (ch === endChar) {\n        state.f = state.inline = inlineNormal;\n        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n        var returnState = getType(state);\n        state.linkHref = false;\n        return returnState;\n      }\n\n      stream.match(linkRE[endChar])\n      state.linkHref = true;\n      return getType(state);\n    };\n  }\n\n  function footnoteLink(stream, state) {\n    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\n      state.f = footnoteLinkInside;\n      stream.next(); // Consume [\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      state.linkText = true;\n      return getType(state);\n    }\n    return switchInline(stream, state, inlineNormal);\n  }\n\n  function footnoteLinkInside(stream, state) {\n    if (stream.match(/^\\]:/, true)) {\n      state.f = state.inline = footnoteUrl;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var returnType = getType(state);\n      state.linkText = false;\n      return returnType;\n    }\n\n    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\n\n    return tokenTypes.linkText;\n  }\n\n  function footnoteUrl(stream, state) {\n    // Check if space, and return NULL if so (to avoid marking the space)\n    if(stream.eatSpace()){\n      return null;\n    }\n    // Match URL\n    stream.match(/^[^\\s]+/, true);\n    // Check for link title\n    if (stream.peek() === undefined) { // End of line, set flag to check next line\n      state.linkTitle = true;\n    } else { // More content on line, check if link title\n      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\n    }\n    state.f = state.inline = inlineNormal;\n    return tokenTypes.linkHref + \" url\";\n  }\n\n  var mode = {\n    startState: function() {\n      return {\n        f: blockNormal,\n\n        prevLine: {stream: null},\n        thisLine: {stream: null},\n\n        block: blockNormal,\n        htmlState: null,\n        indentation: 0,\n\n        inline: inlineNormal,\n        text: handleText,\n\n        formatting: false,\n        linkText: false,\n        linkHref: false,\n        linkTitle: false,\n        code: 0,\n        em: false,\n        strong: false,\n        header: 0,\n        setext: 0,\n        hr: false,\n        taskList: false,\n        list: false,\n        listStack: [],\n        quote: 0,\n        trailingSpace: 0,\n        trailingSpaceNewLine: false,\n        strikethrough: false,\n        emoji: false,\n        fencedEndRE: null\n      };\n    },\n\n    copyState: function(s) {\n      return {\n        f: s.f,\n\n        prevLine: s.prevLine,\n        thisLine: s.thisLine,\n\n        block: s.block,\n        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\n        indentation: s.indentation,\n\n        localMode: s.localMode,\n        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\n\n        inline: s.inline,\n        text: s.text,\n        formatting: false,\n        linkText: s.linkText,\n        linkTitle: s.linkTitle,\n        code: s.code,\n        em: s.em,\n        strong: s.strong,\n        strikethrough: s.strikethrough,\n        emoji: s.emoji,\n        header: s.header,\n        setext: s.setext,\n        hr: s.hr,\n        taskList: s.taskList,\n        list: s.list,\n        listStack: s.listStack.slice(0),\n        quote: s.quote,\n        indentedCode: s.indentedCode,\n        trailingSpace: s.trailingSpace,\n        trailingSpaceNewLine: s.trailingSpaceNewLine,\n        md_inside: s.md_inside,\n        fencedEndRE: s.fencedEndRE\n      };\n    },\n\n    token: function(stream, state) {\n\n      // Reset state.formatting\n      state.formatting = false;\n\n      if (stream != state.thisLine.stream) {\n        state.header = 0;\n        state.hr = false;\n\n        if (stream.match(/^\\s*$/, true)) {\n          blankLine(state);\n          return null;\n        }\n\n        state.prevLine = state.thisLine\n        state.thisLine = {stream: stream}\n\n        // Reset state.taskList\n        state.taskList = false;\n\n        // Reset state.trailingSpace\n        state.trailingSpace = 0;\n        state.trailingSpaceNewLine = false;\n\n        if (!state.localState) {\n          state.f = state.block;\n          if (state.f != htmlBlock) {\n            var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, expandedTab).length;\n            state.indentation = indentation;\n            state.indentationDiff = null;\n            if (indentation > 0) return null;\n          }\n        }\n      }\n      return state.f(stream, state);\n    },\n\n    innerMode: function(state) {\n      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\n      if (state.localState) return {state: state.localState, mode: state.localMode};\n      return {state: state, mode: mode};\n    },\n\n    indent: function(state, textAfter, line) {\n      if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line)\n      if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line)\n      return CodeMirror.Pass\n    },\n\n    blankLine: blankLine,\n\n    getType: getType,\n\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n    fold: \"markdown\"\n  };\n  return mode;\n}, \"xml\");\n\nCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/markdown/markdown.js\n// module id = 8\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.modeInfo = [\n    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\n    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-encrypted\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"asc\", \"pgp\", \"sig\"]},\n    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\n    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\n    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\n    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\"]},\n    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\n    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\n    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\"]},\n    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\", \"cljc\", \"cljx\"]},\n    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\n    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\n    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\n    {name: \"CoffeeScript\", mimes: [\"application/vnd.coffeescript\", \"text/coffeescript\", \"text/x-coffeescript\"], mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\n    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\n    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\n    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\n    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\n    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\n    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\n    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\n    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\n    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\n    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\n    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\n    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\n    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\n    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\n    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\n    {name: \"edn\", mime: \"application/edn\", mode: \"clojure\", ext: [\"edn\"]},\n    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\n    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\n    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\n    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\n    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\n    {name: \"Esper\", mime: \"text/x-esper\", mode: \"sql\"},\n    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\n    {name: \"FCL\", mime: \"text/x-fcl\", mode: \"fcl\"},\n    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\n    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\"]},\n    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\n    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\n    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\n    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\n    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\n    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\", \"gradle\"], file: /^Jenkinsfile$/},\n    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\n    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\n    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\n    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\n    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\n    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\n    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\"], alias: [\"xhtml\"]},\n    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\n    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\n    {name: \"Pug\", mime: \"text/x-pug\", mode: \"pug\", ext: [\"jade\", \"pug\"], alias: [\"jade\"]},\n    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\n    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\n    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\n     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\n    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\n    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\n    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\n    {name: \"Jinja2\", mime: \"null\", mode: \"jinja2\"},\n    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\n    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\n    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\n    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\n    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\n    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\n    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\n    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\n    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\"]},\n    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\n    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\", ext: [\"mps\"]},\n    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\n    {name: \"mbox\", mime: \"application/mbox\", mode: \"mbox\", ext: [\"mbox\"]},\n    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\n    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\n    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\n    {name: \"NTriples\", mimes: [\"application/n-triples\", \"application/n-quads\", \"text/n-triples\"],\n     mode: \"ntriples\", ext: [\"nt\", \"nq\"]},\n    {name: \"Objective C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\", \"mm\"], alias: [\"objective-c\", \"objc\"]},\n    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\n    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\n    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\n    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\n    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\n    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\n    {name: \"PHP\", mime: [\"application/x-httpd-php\", \"text/x-php\"], mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"php7\", \"phtml\"]},\n    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\n    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\n    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\n    {name: \"PowerShell\", mime: \"application/x-powershell\", mode: \"powershell\", ext: [\"ps1\", \"psd1\", \"psm1\"]},\n    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\n    {name: \"ProtoBuf\", mime: \"text/x-protobuf\", mode: \"protobuf\", ext: [\"proto\"]},\n    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"BUILD\", \"bzl\", \"py\", \"pyw\"], file: /^(BUCK|BUILD)$/},\n    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\n    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\n    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\", \"R\"], alias: [\"rscript\"]},\n    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\n    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\n    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\n    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\n    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\n    {name: \"SAS\", mime: \"text/x-sas\", mode: \"sas\", ext: [\"sas\"]},\n    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\n    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\n    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\n    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\n    {name: \"Shell\", mimes: [\"text/x-sh\", \"application/x-sh\"], mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\n    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\n    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\n    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\n    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\n    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\n    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\n    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\n    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\n    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\n    {name: \"SQLite\", mime: \"text/x-sqlite\", mode: \"sql\"},\n    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\n    {name: \"Stylus\", mime: \"text/x-styl\", mode: \"stylus\", ext: [\"styl\"]},\n    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\n    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\n    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\"], alias: [\"tex\"]},\n    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\", \"sv\", \"svh\"]},\n    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\n    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\n    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\n    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\n    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\n    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\n    {name: \"troff\", mime: \"text/troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\n    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\n    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\n    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\n    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\n    {name: \"TypeScript-JSX\", mime: \"text/typescript-jsx\", mode: \"jsx\", ext: [\"tsx\"], alias: [\"tsx\"]},\n    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\n    {name: \"Web IDL\", mime: \"text/x-webidl\", mode: \"webidl\", ext: [\"webidl\"]},\n    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\n    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\n    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\n    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\n    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\n    {name: \"Vue.js Component\", mimes: [\"script/x-vue\", \"text/x-vue\"], mode: \"vue\", ext: [\"vue\"]},\n    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\", \"svg\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\n    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\n    {name: \"Yacas\", mime: \"text/x-yacas\", mode: \"yacas\", ext: [\"ys\"]},\n    {name: \"YAML\", mimes: [\"text/x-yaml\", \"text/yaml\"], mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\n    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\n    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\n    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\n    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\n  ];\n  // Ensure all modes have a mime property for backwards compatibility\n  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n    var info = CodeMirror.modeInfo[i];\n    if (info.mimes) info.mime = info.mimes[0];\n  }\n\n  CodeMirror.findModeByMIME = function(mime) {\n    mime = mime.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.mime == mime) return info;\n      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\n        if (info.mimes[j] == mime) return info;\n    }\n    if (/\\+xml$/.test(mime)) return CodeMirror.findModeByMIME(\"application/xml\")\n    if (/\\+json$/.test(mime)) return CodeMirror.findModeByMIME(\"application/json\")\n  };\n\n  CodeMirror.findModeByExtension = function(ext) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.ext) for (var j = 0; j < info.ext.length; j++)\n        if (info.ext[j] == ext) return info;\n    }\n  };\n\n  CodeMirror.findModeByFileName = function(filename) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.file && info.file.test(filename)) return info;\n    }\n    var dot = filename.lastIndexOf(\".\");\n    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\n    if (ext) return CodeMirror.findModeByExtension(ext);\n  };\n\n  CodeMirror.findModeByName = function(name) {\n    name = name.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.name.toLowerCase() == name) return info;\n      if (info.alias) for (var j = 0; j < info.alias.length; j++)\n        if (info.alias[j].toLowerCase() == name) return info;\n    }\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/meta.js\n// module id = 9\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"yaml\", function() {\n\n  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\n  var keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\n  return {\n    token: function(stream, state) {\n      var ch = stream.peek();\n      var esc = state.escaped;\n      state.escaped = false;\n      /* comments */\n      if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n        return \"string\";\n\n      if (state.literal && stream.indentation() > state.keyCol) {\n        stream.skipToEnd(); return \"string\";\n      } else if (state.literal) { state.literal = false; }\n      if (stream.sol()) {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        /* document start */\n        if(stream.match(/---/)) { return \"def\"; }\n        /* document end */\n        if (stream.match(/\\.\\.\\./)) { return \"def\"; }\n        /* array list item */\n        if (stream.match(/\\s*-\\s+/)) { return 'meta'; }\n      }\n      /* inline pairs/lists */\n      if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n        if (ch == '{')\n          state.inlinePairs++;\n        else if (ch == '}')\n          state.inlinePairs--;\n        else if (ch == '[')\n          state.inlineList++;\n        else\n          state.inlineList--;\n        return 'meta';\n      }\n\n      /* list seperator */\n      if (state.inlineList > 0 && !esc && ch == ',') {\n        stream.next();\n        return 'meta';\n      }\n      /* pairs seperator */\n      if (state.inlinePairs > 0 && !esc && ch == ',') {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        stream.next();\n        return 'meta';\n      }\n\n      /* start of value of a pair */\n      if (state.pairStart) {\n        /* block literals */\n        if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n        /* references */\n        if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable-2'; }\n        /* numbers */\n        if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n        if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n        /* keywords */\n        if (stream.match(keywordRegex)) { return 'keyword'; }\n      }\n\n      /* pairs (associative arrays) -> key */\n      if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^#]*?(?=\\s*:($|\\s))/)) {\n        state.pair = true;\n        state.keyCol = stream.indentation();\n        return \"atom\";\n      }\n      if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n      /* nothing found, continue */\n      state.pairStart = false;\n      state.escaped = (ch == '\\\\');\n      stream.next();\n      return null;\n    },\n    startState: function() {\n      return {\n        pair: false,\n        pairStart: false,\n        keyCol: 0,\n        inlinePairs: 0,\n        inlineList: 0,\n        literal: false,\n        escaped: false\n      };\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-yaml\", \"yaml\");\nCodeMirror.defineMIME(\"text/yaml\", \"yaml\");\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/yaml/yaml.js\n// module id = 10\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode('shell', function() {\n\n  var words = {};\n  function define(style, string) {\n    var split = string.split(' ');\n    for(var i = 0; i < split.length; i++) {\n      words[split[i]] = style;\n    }\n  };\n\n  // Atoms\n  define('atom', 'true false');\n\n  // Keywords\n  define('keyword', 'if then do else elif while until for in esac fi fin ' +\n    'fil done exit set unset export function');\n\n  // Commands\n  define('builtin', 'ab awk bash beep cat cc cd chown chmod chroot clear cp ' +\n    'curl cut diff echo find gawk gcc get git grep hg kill killall ln ls make ' +\n    'mkdir openssl mv nc node npm ping ps restart rm rmdir sed service sh ' +\n    'shopt shred source sort sleep ssh start stop su sudo svn tee telnet top ' +\n    'touch vi vim wall wc wget who write yes zsh');\n\n  function tokenBase(stream, state) {\n    if (stream.eatSpace()) return null;\n\n    var sol = stream.sol();\n    var ch = stream.next();\n\n    if (ch === '\\\\') {\n      stream.next();\n      return null;\n    }\n    if (ch === '\\'' || ch === '\"' || ch === '`') {\n      state.tokens.unshift(tokenString(ch, ch === \"`\" ? \"quote\" : \"string\"));\n      return tokenize(stream, state);\n    }\n    if (ch === '#') {\n      if (sol && stream.eat('!')) {\n        stream.skipToEnd();\n        return 'meta'; // 'comment'?\n      }\n      stream.skipToEnd();\n      return 'comment';\n    }\n    if (ch === '$') {\n      state.tokens.unshift(tokenDollar);\n      return tokenize(stream, state);\n    }\n    if (ch === '+' || ch === '=') {\n      return 'operator';\n    }\n    if (ch === '-') {\n      stream.eat('-');\n      stream.eatWhile(/\\w/);\n      return 'attribute';\n    }\n    if (/\\d/.test(ch)) {\n      stream.eatWhile(/\\d/);\n      if(stream.eol() || !/\\w/.test(stream.peek())) {\n        return 'number';\n      }\n    }\n    stream.eatWhile(/[\\w-]/);\n    var cur = stream.current();\n    if (stream.peek() === '=' && /\\w+/.test(cur)) return 'def';\n    return words.hasOwnProperty(cur) ? words[cur] : null;\n  }\n\n  function tokenString(quote, style) {\n    var close = quote == \"(\" ? \")\" : quote == \"{\" ? \"}\" : quote\n    return function(stream, state) {\n      var next, end = false, escaped = false;\n      while ((next = stream.next()) != null) {\n        if (next === close && !escaped) {\n          end = true;\n          break;\n        }\n        if (next === '$' && !escaped && quote !== \"'\") {\n          escaped = true;\n          stream.backUp(1);\n          state.tokens.unshift(tokenDollar);\n          break;\n        }\n        if (!escaped && next === quote && quote !== close) {\n          state.tokens.unshift(tokenString(quote, style))\n          return tokenize(stream, state)\n        }\n        escaped = !escaped && next === '\\\\';\n      }\n      if (end) state.tokens.shift();\n      return style;\n    };\n  };\n\n  var tokenDollar = function(stream, state) {\n    if (state.tokens.length > 1) stream.eat('$');\n    var ch = stream.next()\n    if (/['\"({]/.test(ch)) {\n      state.tokens[0] = tokenString(ch, ch == \"(\" ? \"quote\" : ch == \"{\" ? \"def\" : \"string\");\n      return tokenize(stream, state);\n    }\n    if (!/\\d/.test(ch)) stream.eatWhile(/\\w/);\n    state.tokens.shift();\n    return 'def';\n  };\n\n  function tokenize(stream, state) {\n    return (state.tokens[0] || tokenBase) (stream, state);\n  };\n\n  return {\n    startState: function() {return {tokens:[]};},\n    token: function(stream, state) {\n      return tokenize(stream, state);\n    },\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n    lineComment: '#',\n    fold: \"brace\"\n  };\n});\n\nCodeMirror.defineMIME('text/x-sh', 'shell');\n// Apache uses a slightly different Media Type for Shell scripts\n// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types\nCodeMirror.defineMIME('application/x-sh', 'shell');\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/shell/shell.js\n// module id = 11\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"go\", function(config) {\n  var indentUnit = config.indentUnit;\n\n  var keywords = {\n    \"break\":true, \"case\":true, \"chan\":true, \"const\":true, \"continue\":true,\n    \"default\":true, \"defer\":true, \"else\":true, \"fallthrough\":true, \"for\":true,\n    \"func\":true, \"go\":true, \"goto\":true, \"if\":true, \"import\":true,\n    \"interface\":true, \"map\":true, \"package\":true, \"range\":true, \"return\":true,\n    \"select\":true, \"struct\":true, \"switch\":true, \"type\":true, \"var\":true,\n    \"bool\":true, \"byte\":true, \"complex64\":true, \"complex128\":true,\n    \"float32\":true, \"float64\":true, \"int8\":true, \"int16\":true, \"int32\":true,\n    \"int64\":true, \"string\":true, \"uint8\":true, \"uint16\":true, \"uint32\":true,\n    \"uint64\":true, \"int\":true, \"uint\":true, \"uintptr\":true, \"error\": true,\n    \"rune\":true\n  };\n\n  var atoms = {\n    \"true\":true, \"false\":true, \"iota\":true, \"nil\":true, \"append\":true,\n    \"cap\":true, \"close\":true, \"complex\":true, \"copy\":true, \"delete\":true, \"imag\":true,\n    \"len\":true, \"make\":true, \"new\":true, \"panic\":true, \"print\":true,\n    \"println\":true, \"real\":true, \"recover\":true\n  };\n\n  var isOperatorChar = /[+\\-*&^%:=<>!|\\/]/;\n\n  var curPunc;\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\" || ch == \"`\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    if (/[\\d\\.]/.test(ch)) {\n      if (ch == \".\") {\n        stream.match(/^[0-9]+([eE][\\-+]?[0-9]+)?/);\n      } else if (ch == \"0\") {\n        stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);\n      } else {\n        stream.match(/^[0-9]*\\.?[0-9]*([eE][\\-+]?[0-9]+)?/);\n      }\n      return \"number\";\n    }\n    if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      curPunc = ch;\n      return null;\n    }\n    if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n    }\n    if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return \"operator\";\n    }\n    stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n    var cur = stream.current();\n    if (keywords.propertyIsEnumerable(cur)) {\n      if (cur == \"case\" || cur == \"default\") curPunc = \"case\";\n      return \"keyword\";\n    }\n    if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n    return \"variable\";\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && quote != \"`\" && next == \"\\\\\";\n      }\n      if (end || !(escaped || quote == \"`\"))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    return state.context = new Context(state.indented, col, type, null, state.context);\n  }\n  function popContext(state) {\n    if (!state.context.prev) return;\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\")\n      state.indented = state.context.indented;\n    return state.context = state.context.prev;\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      return {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n        if (ctx.type == \"case\") ctx.type = \"}\";\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n      else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n      else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n      else if (curPunc == \"case\") ctx.type = \"case\";\n      else if (curPunc == \"}\" && ctx.type == \"}\") popContext(state);\n      else if (curPunc == ctx.type) popContext(state);\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"case\" && /^(?:case|default)\\b/.test(textAfter)) {\n        state.context.type = \"}\";\n        return ctx.indented;\n      }\n      var closing = firstChar == ctx.type;\n      if (ctx.align) return ctx.column + (closing ? 0 : 1);\n      else return ctx.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \"{}):\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n    fold: \"brace\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-go\", \"go\");\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/go/go.js\n// module id = 12\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// CodeMirror2 mode/perl/perl.js (text/x-perl) beta 0.10 (2011-11-08)\n// This is a part of CodeMirror from https://github.com/sabaca/CodeMirror_mode_perl (mail@sabaca.com)\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"perl\",function(){\n        // http://perldoc.perl.org\n        var PERL={                                      //   null - magic touch\n                                                        //   1 - keyword\n                                                        //   2 - def\n                                                        //   3 - atom\n                                                        //   4 - operator\n                                                        //   5 - variable-2 (predefined)\n                                                        //   [x,y] - x=1,2,3; y=must be defined if x{...}\n                                                //      PERL operators\n                '->'                            :   4,\n                '++'                            :   4,\n                '--'                            :   4,\n                '**'                            :   4,\n                                                        //   ! ~ \\ and unary + and -\n                '=~'                            :   4,\n                '!~'                            :   4,\n                '*'                             :   4,\n                '/'                             :   4,\n                '%'                             :   4,\n                'x'                             :   4,\n                '+'                             :   4,\n                '-'                             :   4,\n                '.'                             :   4,\n                '<<'                            :   4,\n                '>>'                            :   4,\n                                                        //   named unary operators\n                '<'                             :   4,\n                '>'                             :   4,\n                '<='                            :   4,\n                '>='                            :   4,\n                'lt'                            :   4,\n                'gt'                            :   4,\n                'le'                            :   4,\n                'ge'                            :   4,\n                '=='                            :   4,\n                '!='                            :   4,\n                '<=>'                           :   4,\n                'eq'                            :   4,\n                'ne'                            :   4,\n                'cmp'                           :   4,\n                '~~'                            :   4,\n                '&'                             :   4,\n                '|'                             :   4,\n                '^'                             :   4,\n                '&&'                            :   4,\n                '||'                            :   4,\n                '//'                            :   4,\n                '..'                            :   4,\n                '...'                           :   4,\n                '?'                             :   4,\n                ':'                             :   4,\n                '='                             :   4,\n                '+='                            :   4,\n                '-='                            :   4,\n                '*='                            :   4,  //   etc. ???\n                ','                             :   4,\n                '=>'                            :   4,\n                '::'                            :   4,\n                                                        //   list operators (rightward)\n                'not'                           :   4,\n                'and'                           :   4,\n                'or'                            :   4,\n                'xor'                           :   4,\n                                                //      PERL predefined variables (I know, what this is a paranoid idea, but may be needed for people, who learn PERL, and for me as well, ...and may be for you?;)\n                'BEGIN'                         :   [5,1],\n                'END'                           :   [5,1],\n                'PRINT'                         :   [5,1],\n                'PRINTF'                        :   [5,1],\n                'GETC'                          :   [5,1],\n                'READ'                          :   [5,1],\n                'READLINE'                      :   [5,1],\n                'DESTROY'                       :   [5,1],\n                'TIE'                           :   [5,1],\n                'TIEHANDLE'                     :   [5,1],\n                'UNTIE'                         :   [5,1],\n                'STDIN'                         :    5,\n                'STDIN_TOP'                     :    5,\n                'STDOUT'                        :    5,\n                'STDOUT_TOP'                    :    5,\n                'STDERR'                        :    5,\n                'STDERR_TOP'                    :    5,\n                '$ARG'                          :    5,\n                '$_'                            :    5,\n                '@ARG'                          :    5,\n                '@_'                            :    5,\n                '$LIST_SEPARATOR'               :    5,\n                '$\"'                            :    5,\n                '$PROCESS_ID'                   :    5,\n                '$PID'                          :    5,\n                '$$'                            :    5,\n                '$REAL_GROUP_ID'                :    5,\n                '$GID'                          :    5,\n                '$('                            :    5,\n                '$EFFECTIVE_GROUP_ID'           :    5,\n                '$EGID'                         :    5,\n                '$)'                            :    5,\n                '$PROGRAM_NAME'                 :    5,\n                '$0'                            :    5,\n                '$SUBSCRIPT_SEPARATOR'          :    5,\n                '$SUBSEP'                       :    5,\n                '$;'                            :    5,\n                '$REAL_USER_ID'                 :    5,\n                '$UID'                          :    5,\n                '$<'                            :    5,\n                '$EFFECTIVE_USER_ID'            :    5,\n                '$EUID'                         :    5,\n                '$>'                            :    5,\n                '$a'                            :    5,\n                '$b'                            :    5,\n                '$COMPILING'                    :    5,\n                '$^C'                           :    5,\n                '$DEBUGGING'                    :    5,\n                '$^D'                           :    5,\n                '${^ENCODING}'                  :    5,\n                '$ENV'                          :    5,\n                '%ENV'                          :    5,\n                '$SYSTEM_FD_MAX'                :    5,\n                '$^F'                           :    5,\n                '@F'                            :    5,\n                '${^GLOBAL_PHASE}'              :    5,\n                '$^H'                           :    5,\n                '%^H'                           :    5,\n                '@INC'                          :    5,\n                '%INC'                          :    5,\n                '$INPLACE_EDIT'                 :    5,\n                '$^I'                           :    5,\n                '$^M'                           :    5,\n                '$OSNAME'                       :    5,\n                '$^O'                           :    5,\n                '${^OPEN}'                      :    5,\n                '$PERLDB'                       :    5,\n                '$^P'                           :    5,\n                '$SIG'                          :    5,\n                '%SIG'                          :    5,\n                '$BASETIME'                     :    5,\n                '$^T'                           :    5,\n                '${^TAINT}'                     :    5,\n                '${^UNICODE}'                   :    5,\n                '${^UTF8CACHE}'                 :    5,\n                '${^UTF8LOCALE}'                :    5,\n                '$PERL_VERSION'                 :    5,\n                '$^V'                           :    5,\n                '${^WIN32_SLOPPY_STAT}'         :    5,\n                '$EXECUTABLE_NAME'              :    5,\n                '$^X'                           :    5,\n                '$1'                            :    5, // - regexp $1, $2...\n                '$MATCH'                        :    5,\n                '$&'                            :    5,\n                '${^MATCH}'                     :    5,\n                '$PREMATCH'                     :    5,\n                '$`'                            :    5,\n                '${^PREMATCH}'                  :    5,\n                '$POSTMATCH'                    :    5,\n                \"$'\"                            :    5,\n                '${^POSTMATCH}'                 :    5,\n                '$LAST_PAREN_MATCH'             :    5,\n                '$+'                            :    5,\n                '$LAST_SUBMATCH_RESULT'         :    5,\n                '$^N'                           :    5,\n                '@LAST_MATCH_END'               :    5,\n                '@+'                            :    5,\n                '%LAST_PAREN_MATCH'             :    5,\n                '%+'                            :    5,\n                '@LAST_MATCH_START'             :    5,\n                '@-'                            :    5,\n                '%LAST_MATCH_START'             :    5,\n                '%-'                            :    5,\n                '$LAST_REGEXP_CODE_RESULT'      :    5,\n                '$^R'                           :    5,\n                '${^RE_DEBUG_FLAGS}'            :    5,\n                '${^RE_TRIE_MAXBUF}'            :    5,\n                '$ARGV'                         :    5,\n                '@ARGV'                         :    5,\n                'ARGV'                          :    5,\n                'ARGVOUT'                       :    5,\n                '$OUTPUT_FIELD_SEPARATOR'       :    5,\n                '$OFS'                          :    5,\n                '$,'                            :    5,\n                '$INPUT_LINE_NUMBER'            :    5,\n                '$NR'                           :    5,\n                '$.'                            :    5,\n                '$INPUT_RECORD_SEPARATOR'       :    5,\n                '$RS'                           :    5,\n                '$/'                            :    5,\n                '$OUTPUT_RECORD_SEPARATOR'      :    5,\n                '$ORS'                          :    5,\n                '$\\\\'                           :    5,\n                '$OUTPUT_AUTOFLUSH'             :    5,\n                '$|'                            :    5,\n                '$ACCUMULATOR'                  :    5,\n                '$^A'                           :    5,\n                '$FORMAT_FORMFEED'              :    5,\n                '$^L'                           :    5,\n                '$FORMAT_PAGE_NUMBER'           :    5,\n                '$%'                            :    5,\n                '$FORMAT_LINES_LEFT'            :    5,\n                '$-'                            :    5,\n                '$FORMAT_LINE_BREAK_CHARACTERS' :    5,\n                '$:'                            :    5,\n                '$FORMAT_LINES_PER_PAGE'        :    5,\n                '$='                            :    5,\n                '$FORMAT_TOP_NAME'              :    5,\n                '$^'                            :    5,\n                '$FORMAT_NAME'                  :    5,\n                '$~'                            :    5,\n                '${^CHILD_ERROR_NATIVE}'        :    5,\n                '$EXTENDED_OS_ERROR'            :    5,\n                '$^E'                           :    5,\n                '$EXCEPTIONS_BEING_CAUGHT'      :    5,\n                '$^S'                           :    5,\n                '$WARNING'                      :    5,\n                '$^W'                           :    5,\n                '${^WARNING_BITS}'              :    5,\n                '$OS_ERROR'                     :    5,\n                '$ERRNO'                        :    5,\n                '$!'                            :    5,\n                '%OS_ERROR'                     :    5,\n                '%ERRNO'                        :    5,\n                '%!'                            :    5,\n                '$CHILD_ERROR'                  :    5,\n                '$?'                            :    5,\n                '$EVAL_ERROR'                   :    5,\n                '$@'                            :    5,\n                '$OFMT'                         :    5,\n                '$#'                            :    5,\n                '$*'                            :    5,\n                '$ARRAY_BASE'                   :    5,\n                '$['                            :    5,\n                '$OLD_PERL_VERSION'             :    5,\n                '$]'                            :    5,\n                                                //      PERL blocks\n                'if'                            :[1,1],\n                elsif                           :[1,1],\n                'else'                          :[1,1],\n                'while'                         :[1,1],\n                unless                          :[1,1],\n                'for'                           :[1,1],\n                foreach                         :[1,1],\n                                                //      PERL functions\n                'abs'                           :1,     // - absolute value function\n                accept                          :1,     // - accept an incoming socket connect\n                alarm                           :1,     // - schedule a SIGALRM\n                'atan2'                         :1,     // - arctangent of Y/X in the range -PI to PI\n                bind                            :1,     // - binds an address to a socket\n                binmode                         :1,     // - prepare binary files for I/O\n                bless                           :1,     // - create an object\n                bootstrap                       :1,     //\n                'break'                         :1,     // - break out of a \"given\" block\n                caller                          :1,     // - get context of the current subroutine call\n                chdir                           :1,     // - change your current working directory\n                chmod                           :1,     // - changes the permissions on a list of files\n                chomp                           :1,     // - remove a trailing record separator from a string\n                chop                            :1,     // - remove the last character from a string\n                chown                           :1,     // - change the ownership on a list of files\n                chr                             :1,     // - get character this number represents\n                chroot                          :1,     // - make directory new root for path lookups\n                close                           :1,     // - close file (or pipe or socket) handle\n                closedir                        :1,     // - close directory handle\n                connect                         :1,     // - connect to a remote socket\n                'continue'                      :[1,1], // - optional trailing block in a while or foreach\n                'cos'                           :1,     // - cosine function\n                crypt                           :1,     // - one-way passwd-style encryption\n                dbmclose                        :1,     // - breaks binding on a tied dbm file\n                dbmopen                         :1,     // - create binding on a tied dbm file\n                'default'                       :1,     //\n                defined                         :1,     // - test whether a value, variable, or function is defined\n                'delete'                        :1,     // - deletes a value from a hash\n                die                             :1,     // - raise an exception or bail out\n                'do'                            :1,     // - turn a BLOCK into a TERM\n                dump                            :1,     // - create an immediate core dump\n                each                            :1,     // - retrieve the next key/value pair from a hash\n                endgrent                        :1,     // - be done using group file\n                endhostent                      :1,     // - be done using hosts file\n                endnetent                       :1,     // - be done using networks file\n                endprotoent                     :1,     // - be done using protocols file\n                endpwent                        :1,     // - be done using passwd file\n                endservent                      :1,     // - be done using services file\n                eof                             :1,     // - test a filehandle for its end\n                'eval'                          :1,     // - catch exceptions or compile and run code\n                'exec'                          :1,     // - abandon this program to run another\n                exists                          :1,     // - test whether a hash key is present\n                exit                            :1,     // - terminate this program\n                'exp'                           :1,     // - raise I to a power\n                fcntl                           :1,     // - file control system call\n                fileno                          :1,     // - return file descriptor from filehandle\n                flock                           :1,     // - lock an entire file with an advisory lock\n                fork                            :1,     // - create a new process just like this one\n                format                          :1,     // - declare a picture format with use by the write() function\n                formline                        :1,     // - internal function used for formats\n                getc                            :1,     // - get the next character from the filehandle\n                getgrent                        :1,     // - get next group record\n                getgrgid                        :1,     // - get group record given group user ID\n                getgrnam                        :1,     // - get group record given group name\n                gethostbyaddr                   :1,     // - get host record given its address\n                gethostbyname                   :1,     // - get host record given name\n                gethostent                      :1,     // - get next hosts record\n                getlogin                        :1,     // - return who logged in at this tty\n                getnetbyaddr                    :1,     // - get network record given its address\n                getnetbyname                    :1,     // - get networks record given name\n                getnetent                       :1,     // - get next networks record\n                getpeername                     :1,     // - find the other end of a socket connection\n                getpgrp                         :1,     // - get process group\n                getppid                         :1,     // - get parent process ID\n                getpriority                     :1,     // - get current nice value\n                getprotobyname                  :1,     // - get protocol record given name\n                getprotobynumber                :1,     // - get protocol record numeric protocol\n                getprotoent                     :1,     // - get next protocols record\n                getpwent                        :1,     // - get next passwd record\n                getpwnam                        :1,     // - get passwd record given user login name\n                getpwuid                        :1,     // - get passwd record given user ID\n                getservbyname                   :1,     // - get services record given its name\n                getservbyport                   :1,     // - get services record given numeric port\n                getservent                      :1,     // - get next services record\n                getsockname                     :1,     // - retrieve the sockaddr for a given socket\n                getsockopt                      :1,     // - get socket options on a given socket\n                given                           :1,     //\n                glob                            :1,     // - expand filenames using wildcards\n                gmtime                          :1,     // - convert UNIX time into record or string using Greenwich time\n                'goto'                          :1,     // - create spaghetti code\n                grep                            :1,     // - locate elements in a list test true against a given criterion\n                hex                             :1,     // - convert a string to a hexadecimal number\n                'import'                        :1,     // - patch a module's namespace into your own\n                index                           :1,     // - find a substring within a string\n                'int'                           :1,     // - get the integer portion of a number\n                ioctl                           :1,     // - system-dependent device control system call\n                'join'                          :1,     // - join a list into a string using a separator\n                keys                            :1,     // - retrieve list of indices from a hash\n                kill                            :1,     // - send a signal to a process or process group\n                last                            :1,     // - exit a block prematurely\n                lc                              :1,     // - return lower-case version of a string\n                lcfirst                         :1,     // - return a string with just the next letter in lower case\n                length                          :1,     // - return the number of bytes in a string\n                'link'                          :1,     // - create a hard link in the filesytem\n                listen                          :1,     // - register your socket as a server\n                local                           : 2,    // - create a temporary value for a global variable (dynamic scoping)\n                localtime                       :1,     // - convert UNIX time into record or string using local time\n                lock                            :1,     // - get a thread lock on a variable, subroutine, or method\n                'log'                           :1,     // - retrieve the natural logarithm for a number\n                lstat                           :1,     // - stat a symbolic link\n                m                               :null,  // - match a string with a regular expression pattern\n                map                             :1,     // - apply a change to a list to get back a new list with the changes\n                mkdir                           :1,     // - create a directory\n                msgctl                          :1,     // - SysV IPC message control operations\n                msgget                          :1,     // - get SysV IPC message queue\n                msgrcv                          :1,     // - receive a SysV IPC message from a message queue\n                msgsnd                          :1,     // - send a SysV IPC message to a message queue\n                my                              : 2,    // - declare and assign a local variable (lexical scoping)\n                'new'                           :1,     //\n                next                            :1,     // - iterate a block prematurely\n                no                              :1,     // - unimport some module symbols or semantics at compile time\n                oct                             :1,     // - convert a string to an octal number\n                open                            :1,     // - open a file, pipe, or descriptor\n                opendir                         :1,     // - open a directory\n                ord                             :1,     // - find a character's numeric representation\n                our                             : 2,    // - declare and assign a package variable (lexical scoping)\n                pack                            :1,     // - convert a list into a binary representation\n                'package'                       :1,     // - declare a separate global namespace\n                pipe                            :1,     // - open a pair of connected filehandles\n                pop                             :1,     // - remove the last element from an array and return it\n                pos                             :1,     // - find or set the offset for the last/next m//g search\n                print                           :1,     // - output a list to a filehandle\n                printf                          :1,     // - output a formatted list to a filehandle\n                prototype                       :1,     // - get the prototype (if any) of a subroutine\n                push                            :1,     // - append one or more elements to an array\n                q                               :null,  // - singly quote a string\n                qq                              :null,  // - doubly quote a string\n                qr                              :null,  // - Compile pattern\n                quotemeta                       :null,  // - quote regular expression magic characters\n                qw                              :null,  // - quote a list of words\n                qx                              :null,  // - backquote quote a string\n                rand                            :1,     // - retrieve the next pseudorandom number\n                read                            :1,     // - fixed-length buffered input from a filehandle\n                readdir                         :1,     // - get a directory from a directory handle\n                readline                        :1,     // - fetch a record from a file\n                readlink                        :1,     // - determine where a symbolic link is pointing\n                readpipe                        :1,     // - execute a system command and collect standard output\n                recv                            :1,     // - receive a message over a Socket\n                redo                            :1,     // - start this loop iteration over again\n                ref                             :1,     // - find out the type of thing being referenced\n                rename                          :1,     // - change a filename\n                require                         :1,     // - load in external functions from a library at runtime\n                reset                           :1,     // - clear all variables of a given name\n                'return'                        :1,     // - get out of a function early\n                reverse                         :1,     // - flip a string or a list\n                rewinddir                       :1,     // - reset directory handle\n                rindex                          :1,     // - right-to-left substring search\n                rmdir                           :1,     // - remove a directory\n                s                               :null,  // - replace a pattern with a string\n                say                             :1,     // - print with newline\n                scalar                          :1,     // - force a scalar context\n                seek                            :1,     // - reposition file pointer for random-access I/O\n                seekdir                         :1,     // - reposition directory pointer\n                select                          :1,     // - reset default output or do I/O multiplexing\n                semctl                          :1,     // - SysV semaphore control operations\n                semget                          :1,     // - get set of SysV semaphores\n                semop                           :1,     // - SysV semaphore operations\n                send                            :1,     // - send a message over a socket\n                setgrent                        :1,     // - prepare group file for use\n                sethostent                      :1,     // - prepare hosts file for use\n                setnetent                       :1,     // - prepare networks file for use\n                setpgrp                         :1,     // - set the process group of a process\n                setpriority                     :1,     // - set a process's nice value\n                setprotoent                     :1,     // - prepare protocols file for use\n                setpwent                        :1,     // - prepare passwd file for use\n                setservent                      :1,     // - prepare services file for use\n                setsockopt                      :1,     // - set some socket options\n                shift                           :1,     // - remove the first element of an array, and return it\n                shmctl                          :1,     // - SysV shared memory operations\n                shmget                          :1,     // - get SysV shared memory segment identifier\n                shmread                         :1,     // - read SysV shared memory\n                shmwrite                        :1,     // - write SysV shared memory\n                shutdown                        :1,     // - close down just half of a socket connection\n                'sin'                           :1,     // - return the sine of a number\n                sleep                           :1,     // - block for some number of seconds\n                socket                          :1,     // - create a socket\n                socketpair                      :1,     // - create a pair of sockets\n                'sort'                          :1,     // - sort a list of values\n                splice                          :1,     // - add or remove elements anywhere in an array\n                'split'                         :1,     // - split up a string using a regexp delimiter\n                sprintf                         :1,     // - formatted print into a string\n                'sqrt'                          :1,     // - square root function\n                srand                           :1,     // - seed the random number generator\n                stat                            :1,     // - get a file's status information\n                state                           :1,     // - declare and assign a state variable (persistent lexical scoping)\n                study                           :1,     // - optimize input data for repeated searches\n                'sub'                           :1,     // - declare a subroutine, possibly anonymously\n                'substr'                        :1,     // - get or alter a portion of a stirng\n                symlink                         :1,     // - create a symbolic link to a file\n                syscall                         :1,     // - execute an arbitrary system call\n                sysopen                         :1,     // - open a file, pipe, or descriptor\n                sysread                         :1,     // - fixed-length unbuffered input from a filehandle\n                sysseek                         :1,     // - position I/O pointer on handle used with sysread and syswrite\n                system                          :1,     // - run a separate program\n                syswrite                        :1,     // - fixed-length unbuffered output to a filehandle\n                tell                            :1,     // - get current seekpointer on a filehandle\n                telldir                         :1,     // - get current seekpointer on a directory handle\n                tie                             :1,     // - bind a variable to an object class\n                tied                            :1,     // - get a reference to the object underlying a tied variable\n                time                            :1,     // - return number of seconds since 1970\n                times                           :1,     // - return elapsed time for self and child processes\n                tr                              :null,  // - transliterate a string\n                truncate                        :1,     // - shorten a file\n                uc                              :1,     // - return upper-case version of a string\n                ucfirst                         :1,     // - return a string with just the next letter in upper case\n                umask                           :1,     // - set file creation mode mask\n                undef                           :1,     // - remove a variable or function definition\n                unlink                          :1,     // - remove one link to a file\n                unpack                          :1,     // - convert binary structure into normal perl variables\n                unshift                         :1,     // - prepend more elements to the beginning of a list\n                untie                           :1,     // - break a tie binding to a variable\n                use                             :1,     // - load in a module at compile time\n                utime                           :1,     // - set a file's last access and modify times\n                values                          :1,     // - return a list of the values in a hash\n                vec                             :1,     // - test or set particular bits in a string\n                wait                            :1,     // - wait for any child process to die\n                waitpid                         :1,     // - wait for a particular child process to die\n                wantarray                       :1,     // - get void vs scalar vs list context of current subroutine call\n                warn                            :1,     // - print debugging info\n                when                            :1,     //\n                write                           :1,     // - print a picture record\n                y                               :null}; // - transliterate a string\n\n        var RXstyle=\"string-2\";\n        var RXmodifiers=/[goseximacplud]/;              // NOTE: \"m\", \"s\", \"y\" and \"tr\" need to correct real modifiers for each regexp type\n\n        function tokenChain(stream,state,chain,style,tail){     // NOTE: chain.length > 2 is not working now (it's for s[...][...]geos;)\n                state.chain=null;                               //                                                          12   3tail\n                state.style=null;\n                state.tail=null;\n                state.tokenize=function(stream,state){\n                        var e=false,c,i=0;\n                        while(c=stream.next()){\n                                if(c===chain[i]&&!e){\n                                        if(chain[++i]!==undefined){\n                                                state.chain=chain[i];\n                                                state.style=style;\n                                                state.tail=tail;}\n                                        else if(tail)\n                                                stream.eatWhile(tail);\n                                        state.tokenize=tokenPerl;\n                                        return style;}\n                                e=!e&&c==\"\\\\\";}\n                        return style;};\n                return state.tokenize(stream,state);}\n\n        function tokenSOMETHING(stream,state,string){\n                state.tokenize=function(stream,state){\n                        if(stream.string==string)\n                                state.tokenize=tokenPerl;\n                        stream.skipToEnd();\n                        return \"string\";};\n                return state.tokenize(stream,state);}\n\n        function tokenPerl(stream,state){\n                if(stream.eatSpace())\n                        return null;\n                if(state.chain)\n                        return tokenChain(stream,state,state.chain,state.style,state.tail);\n                if(stream.match(/^\\-?[\\d\\.]/,false))\n                        if(stream.match(/^(\\-?(\\d*\\.\\d+(e[+-]?\\d+)?|\\d+\\.\\d*)|0x[\\da-fA-F]+|0b[01]+|\\d+(e[+-]?\\d+)?)/))\n                                return 'number';\n                if(stream.match(/^<<(?=\\w)/)){                  // NOTE: <<SOMETHING\\n...\\nSOMETHING\\n\n                        stream.eatWhile(/\\w/);\n                        return tokenSOMETHING(stream,state,stream.current().substr(2));}\n                if(stream.sol()&&stream.match(/^\\=item(?!\\w)/)){// NOTE: \\n=item...\\n=cut\\n\n                        return tokenSOMETHING(stream,state,'=cut');}\n                var ch=stream.next();\n                if(ch=='\"'||ch==\"'\"){                           // NOTE: ' or \" or <<'SOMETHING'\\n...\\nSOMETHING\\n or <<\"SOMETHING\"\\n...\\nSOMETHING\\n\n                        if(prefix(stream, 3)==\"<<\"+ch){\n                                var p=stream.pos;\n                                stream.eatWhile(/\\w/);\n                                var n=stream.current().substr(1);\n                                if(n&&stream.eat(ch))\n                                        return tokenSOMETHING(stream,state,n);\n                                stream.pos=p;}\n                        return tokenChain(stream,state,[ch],\"string\");}\n                if(ch==\"q\"){\n                        var c=look(stream, -2);\n                        if(!(c&&/\\w/.test(c))){\n                                c=look(stream, 0);\n                                if(c==\"x\"){\n                                        c=look(stream, 1);\n                                        if(c==\"(\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\")\"],RXstyle,RXmodifiers);}\n                                        if(c==\"[\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\"]\"],RXstyle,RXmodifiers);}\n                                        if(c==\"{\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\"}\"],RXstyle,RXmodifiers);}\n                                        if(c==\"<\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\">\"],RXstyle,RXmodifiers);}\n                                        if(/[\\^'\"!~\\/]/.test(c)){\n                                                eatSuffix(stream, 1);\n                                                return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}\n                                else if(c==\"q\"){\n                                        c=look(stream, 1);\n                                        if(c==\"(\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\")\"],\"string\");}\n                                        if(c==\"[\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\"]\"],\"string\");}\n                                        if(c==\"{\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\"}\"],\"string\");}\n                                        if(c==\"<\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\">\"],\"string\");}\n                                        if(/[\\^'\"!~\\/]/.test(c)){\n                                                eatSuffix(stream, 1);\n                                                return tokenChain(stream,state,[stream.eat(c)],\"string\");}}\n                                else if(c==\"w\"){\n                                        c=look(stream, 1);\n                                        if(c==\"(\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\")\"],\"bracket\");}\n                                        if(c==\"[\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\"]\"],\"bracket\");}\n                                        if(c==\"{\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\"}\"],\"bracket\");}\n                                        if(c==\"<\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\">\"],\"bracket\");}\n                                        if(/[\\^'\"!~\\/]/.test(c)){\n                                                eatSuffix(stream, 1);\n                                                return tokenChain(stream,state,[stream.eat(c)],\"bracket\");}}\n                                else if(c==\"r\"){\n                                        c=look(stream, 1);\n                                        if(c==\"(\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\")\"],RXstyle,RXmodifiers);}\n                                        if(c==\"[\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\"]\"],RXstyle,RXmodifiers);}\n                                        if(c==\"{\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\"}\"],RXstyle,RXmodifiers);}\n                                        if(c==\"<\"){\n                                                eatSuffix(stream, 2);\n                                                return tokenChain(stream,state,[\">\"],RXstyle,RXmodifiers);}\n                                        if(/[\\^'\"!~\\/]/.test(c)){\n                                                eatSuffix(stream, 1);\n                                                return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}\n                                else if(/[\\^'\"!~\\/(\\[{<]/.test(c)){\n                                        if(c==\"(\"){\n                                                eatSuffix(stream, 1);\n                                                return tokenChain(stream,state,[\")\"],\"string\");}\n                                        if(c==\"[\"){\n                                                eatSuffix(stream, 1);\n                                                return tokenChain(stream,state,[\"]\"],\"string\");}\n                                        if(c==\"{\"){\n                                                eatSuffix(stream, 1);\n                                                return tokenChain(stream,state,[\"}\"],\"string\");}\n                                        if(c==\"<\"){\n                                                eatSuffix(stream, 1);\n                                                return tokenChain(stream,state,[\">\"],\"string\");}\n                                        if(/[\\^'\"!~\\/]/.test(c)){\n                                                return tokenChain(stream,state,[stream.eat(c)],\"string\");}}}}\n                if(ch==\"m\"){\n                        var c=look(stream, -2);\n                        if(!(c&&/\\w/.test(c))){\n                                c=stream.eat(/[(\\[{<\\^'\"!~\\/]/);\n                                if(c){\n                                        if(/[\\^'\"!~\\/]/.test(c)){\n                                                return tokenChain(stream,state,[c],RXstyle,RXmodifiers);}\n                                        if(c==\"(\"){\n                                                return tokenChain(stream,state,[\")\"],RXstyle,RXmodifiers);}\n                                        if(c==\"[\"){\n                                                return tokenChain(stream,state,[\"]\"],RXstyle,RXmodifiers);}\n                                        if(c==\"{\"){\n                                                return tokenChain(stream,state,[\"}\"],RXstyle,RXmodifiers);}\n                                        if(c==\"<\"){\n                                                return tokenChain(stream,state,[\">\"],RXstyle,RXmodifiers);}}}}\n                if(ch==\"s\"){\n                        var c=/[\\/>\\]})\\w]/.test(look(stream, -2));\n                        if(!c){\n                                c=stream.eat(/[(\\[{<\\^'\"!~\\/]/);\n                                if(c){\n                                        if(c==\"[\")\n                                                return tokenChain(stream,state,[\"]\",\"]\"],RXstyle,RXmodifiers);\n                                        if(c==\"{\")\n                                                return tokenChain(stream,state,[\"}\",\"}\"],RXstyle,RXmodifiers);\n                                        if(c==\"<\")\n                                                return tokenChain(stream,state,[\">\",\">\"],RXstyle,RXmodifiers);\n                                        if(c==\"(\")\n                                                return tokenChain(stream,state,[\")\",\")\"],RXstyle,RXmodifiers);\n                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}\n                if(ch==\"y\"){\n                        var c=/[\\/>\\]})\\w]/.test(look(stream, -2));\n                        if(!c){\n                                c=stream.eat(/[(\\[{<\\^'\"!~\\/]/);\n                                if(c){\n                                        if(c==\"[\")\n                                                return tokenChain(stream,state,[\"]\",\"]\"],RXstyle,RXmodifiers);\n                                        if(c==\"{\")\n                                                return tokenChain(stream,state,[\"}\",\"}\"],RXstyle,RXmodifiers);\n                                        if(c==\"<\")\n                                                return tokenChain(stream,state,[\">\",\">\"],RXstyle,RXmodifiers);\n                                        if(c==\"(\")\n                                                return tokenChain(stream,state,[\")\",\")\"],RXstyle,RXmodifiers);\n                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}\n                if(ch==\"t\"){\n                        var c=/[\\/>\\]})\\w]/.test(look(stream, -2));\n                        if(!c){\n                                c=stream.eat(\"r\");if(c){\n                                c=stream.eat(/[(\\[{<\\^'\"!~\\/]/);\n                                if(c){\n                                        if(c==\"[\")\n                                                return tokenChain(stream,state,[\"]\",\"]\"],RXstyle,RXmodifiers);\n                                        if(c==\"{\")\n                                                return tokenChain(stream,state,[\"}\",\"}\"],RXstyle,RXmodifiers);\n                                        if(c==\"<\")\n                                                return tokenChain(stream,state,[\">\",\">\"],RXstyle,RXmodifiers);\n                                        if(c==\"(\")\n                                                return tokenChain(stream,state,[\")\",\")\"],RXstyle,RXmodifiers);\n                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}}\n                if(ch==\"`\"){\n                        return tokenChain(stream,state,[ch],\"variable-2\");}\n                if(ch==\"/\"){\n                        if(!/~\\s*$/.test(prefix(stream)))\n                                return \"operator\";\n                        else\n                                return tokenChain(stream,state,[ch],RXstyle,RXmodifiers);}\n                if(ch==\"$\"){\n                        var p=stream.pos;\n                        if(stream.eatWhile(/\\d/)||stream.eat(\"{\")&&stream.eatWhile(/\\d/)&&stream.eat(\"}\"))\n                                return \"variable-2\";\n                        else\n                                stream.pos=p;}\n                if(/[$@%]/.test(ch)){\n                        var p=stream.pos;\n                        if(stream.eat(\"^\")&&stream.eat(/[A-Z]/)||!/[@$%&]/.test(look(stream, -2))&&stream.eat(/[=|\\\\\\-#?@;:&`~\\^!\\[\\]*'\"$+.,\\/<>()]/)){\n                                var c=stream.current();\n                                if(PERL[c])\n                                        return \"variable-2\";}\n                        stream.pos=p;}\n                if(/[$@%&]/.test(ch)){\n                        if(stream.eatWhile(/[\\w$\\[\\]]/)||stream.eat(\"{\")&&stream.eatWhile(/[\\w$\\[\\]]/)&&stream.eat(\"}\")){\n                                var c=stream.current();\n                                if(PERL[c])\n                                        return \"variable-2\";\n                                else\n                                        return \"variable\";}}\n                if(ch==\"#\"){\n                        if(look(stream, -2)!=\"$\"){\n                                stream.skipToEnd();\n                                return \"comment\";}}\n                if(/[:+\\-\\^*$&%@=<>!?|\\/~\\.]/.test(ch)){\n                        var p=stream.pos;\n                        stream.eatWhile(/[:+\\-\\^*$&%@=<>!?|\\/~\\.]/);\n                        if(PERL[stream.current()])\n                                return \"operator\";\n                        else\n                                stream.pos=p;}\n                if(ch==\"_\"){\n                        if(stream.pos==1){\n                                if(suffix(stream, 6)==\"_END__\"){\n                                        return tokenChain(stream,state,['\\0'],\"comment\");}\n                                else if(suffix(stream, 7)==\"_DATA__\"){\n                                        return tokenChain(stream,state,['\\0'],\"variable-2\");}\n                                else if(suffix(stream, 7)==\"_C__\"){\n                                        return tokenChain(stream,state,['\\0'],\"string\");}}}\n                if(/\\w/.test(ch)){\n                        var p=stream.pos;\n                        if(look(stream, -2)==\"{\"&&(look(stream, 0)==\"}\"||stream.eatWhile(/\\w/)&&look(stream, 0)==\"}\"))\n                                return \"string\";\n                        else\n                                stream.pos=p;}\n                if(/[A-Z]/.test(ch)){\n                        var l=look(stream, -2);\n                        var p=stream.pos;\n                        stream.eatWhile(/[A-Z_]/);\n                        if(/[\\da-z]/.test(look(stream, 0))){\n                                stream.pos=p;}\n                        else{\n                                var c=PERL[stream.current()];\n                                if(!c)\n                                        return \"meta\";\n                                if(c[1])\n                                        c=c[0];\n                                if(l!=\":\"){\n                                        if(c==1)\n                                                return \"keyword\";\n                                        else if(c==2)\n                                                return \"def\";\n                                        else if(c==3)\n                                                return \"atom\";\n                                        else if(c==4)\n                                                return \"operator\";\n                                        else if(c==5)\n                                                return \"variable-2\";\n                                        else\n                                                return \"meta\";}\n                                else\n                                        return \"meta\";}}\n                if(/[a-zA-Z_]/.test(ch)){\n                        var l=look(stream, -2);\n                        stream.eatWhile(/\\w/);\n                        var c=PERL[stream.current()];\n                        if(!c)\n                                return \"meta\";\n                        if(c[1])\n                                c=c[0];\n                        if(l!=\":\"){\n                                if(c==1)\n                                        return \"keyword\";\n                                else if(c==2)\n                                        return \"def\";\n                                else if(c==3)\n                                        return \"atom\";\n                                else if(c==4)\n                                        return \"operator\";\n                                else if(c==5)\n                                        return \"variable-2\";\n                                else\n                                        return \"meta\";}\n                        else\n                                return \"meta\";}\n                return null;}\n\n        return {\n            startState: function() {\n                return {\n                    tokenize: tokenPerl,\n                    chain: null,\n                    style: null,\n                    tail: null\n                };\n            },\n            token: function(stream, state) {\n                return (state.tokenize || tokenPerl)(stream, state);\n            },\n            lineComment: '#'\n        };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"perl\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/x-perl\", \"perl\");\n\n// it's like \"peek\", but need for look-ahead or look-behind if index < 0\nfunction look(stream, c){\n  return stream.string.charAt(stream.pos+(c||0));\n}\n\n// return a part of prefix of current stream from current position\nfunction prefix(stream, c){\n  if(c){\n    var x=stream.pos-c;\n    return stream.string.substr((x>=0?x:0),c);}\n  else{\n    return stream.string.substr(0,stream.pos-1);\n  }\n}\n\n// return a part of suffix of current stream from current position\nfunction suffix(stream, c){\n  var y=stream.string.length;\n  var x=y-stream.pos+1;\n  return stream.string.substr(stream.pos,(c&&c<y?c:x));\n}\n\n// eating and vomiting a part of stream from current position\nfunction eatSuffix(stream, c){\n  var x=stream.pos+c;\n  var y;\n  if(x<=0)\n    stream.pos=0;\n  else if(x>=(y=stream.string.length-1))\n    stream.pos=y;\n  else\n    stream.pos=x;\n}\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/perl/perl.js\n// module id = 13\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../clike/clike\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../clike/clike\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function keywords(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  // Helper for phpString\n  function matchSequence(list, end, escapes) {\n    if (list.length == 0) return phpString(end);\n    return function (stream, state) {\n      var patterns = list[0];\n      for (var i = 0; i < patterns.length; i++) if (stream.match(patterns[i][0])) {\n        state.tokenize = matchSequence(list.slice(1), end);\n        return patterns[i][1];\n      }\n      state.tokenize = phpString(end, escapes);\n      return \"string\";\n    };\n  }\n  function phpString(closing, escapes) {\n    return function(stream, state) { return phpString_(stream, state, closing, escapes); };\n  }\n  function phpString_(stream, state, closing, escapes) {\n    // \"Complex\" syntax\n    if (escapes !== false && stream.match(\"${\", false) || stream.match(\"{$\", false)) {\n      state.tokenize = null;\n      return \"string\";\n    }\n\n    // Simple syntax\n    if (escapes !== false && stream.match(/^\\$[a-zA-Z_][a-zA-Z0-9_]*/)) {\n      // After the variable name there may appear array or object operator.\n      if (stream.match(\"[\", false)) {\n        // Match array operator\n        state.tokenize = matchSequence([\n          [[\"[\", null]],\n          [[/\\d[\\w\\.]*/, \"number\"],\n           [/\\$[a-zA-Z_][a-zA-Z0-9_]*/, \"variable-2\"],\n           [/[\\w\\$]+/, \"variable\"]],\n          [[\"]\", null]]\n        ], closing, escapes);\n      }\n      if (stream.match(/\\-\\>\\w/, false)) {\n        // Match object operator\n        state.tokenize = matchSequence([\n          [[\"->\", null]],\n          [[/[\\w]+/, \"variable\"]]\n        ], closing, escapes);\n      }\n      return \"variable-2\";\n    }\n\n    var escaped = false;\n    // Normal string\n    while (!stream.eol() &&\n           (escaped || escapes === false ||\n            (!stream.match(\"{$\", false) &&\n             !stream.match(/^(\\$[a-zA-Z_][a-zA-Z0-9_]*|\\$\\{)/, false)))) {\n      if (!escaped && stream.match(closing)) {\n        state.tokenize = null;\n        state.tokStack.pop(); state.tokStack.pop();\n        break;\n      }\n      escaped = stream.next() == \"\\\\\" && !escaped;\n    }\n    return \"string\";\n  }\n\n  var phpKeywords = \"abstract and array as break case catch class clone const continue declare default \" +\n    \"do else elseif enddeclare endfor endforeach endif endswitch endwhile extends final \" +\n    \"for foreach function global goto if implements interface instanceof namespace \" +\n    \"new or private protected public static switch throw trait try use var while xor \" +\n    \"die echo empty exit eval include include_once isset list require require_once return \" +\n    \"print unset __halt_compiler self static parent yield insteadof finally\";\n  var phpAtoms = \"true false null TRUE FALSE NULL __CLASS__ __DIR__ __FILE__ __LINE__ __METHOD__ __FUNCTION__ __NAMESPACE__ __TRAIT__\";\n  var phpBuiltin = \"func_num_args func_get_arg func_get_args strlen strcmp strncmp strcasecmp strncasecmp each error_reporting define defined trigger_error user_error set_error_handler restore_error_handler get_declared_classes get_loaded_extensions extension_loaded get_extension_funcs debug_backtrace constant bin2hex hex2bin sleep usleep time mktime gmmktime strftime gmstrftime strtotime date gmdate getdate localtime checkdate flush wordwrap htmlspecialchars htmlentities html_entity_decode md5 md5_file crc32 getimagesize image_type_to_mime_type phpinfo phpversion phpcredits strnatcmp strnatcasecmp substr_count strspn strcspn strtok strtoupper strtolower strpos strrpos strrev hebrev hebrevc nl2br basename dirname pathinfo stripslashes stripcslashes strstr stristr strrchr str_shuffle str_word_count strcoll substr substr_replace quotemeta ucfirst ucwords strtr addslashes addcslashes rtrim str_replace str_repeat count_chars chunk_split trim ltrim strip_tags similar_text explode implode setlocale localeconv parse_str str_pad chop strchr sprintf printf vprintf vsprintf sscanf fscanf parse_url urlencode urldecode rawurlencode rawurldecode readlink linkinfo link unlink exec system escapeshellcmd escapeshellarg passthru shell_exec proc_open proc_close rand srand getrandmax mt_rand mt_srand mt_getrandmax base64_decode base64_encode abs ceil floor round is_finite is_nan is_infinite bindec hexdec octdec decbin decoct dechex base_convert number_format fmod ip2long long2ip getenv putenv getopt microtime gettimeofday getrusage uniqid quoted_printable_decode set_time_limit get_cfg_var magic_quotes_runtime set_magic_quotes_runtime get_magic_quotes_gpc get_magic_quotes_runtime import_request_variables error_log serialize unserialize memory_get_usage var_dump var_export debug_zval_dump print_r highlight_file show_source highlight_string ini_get ini_get_all ini_set ini_alter ini_restore get_include_path set_include_path restore_include_path setcookie header headers_sent connection_aborted connection_status ignore_user_abort parse_ini_file is_uploaded_file move_uploaded_file intval floatval doubleval strval gettype settype is_null is_resource is_bool is_long is_float is_int is_integer is_double is_real is_numeric is_string is_array is_object is_scalar ereg ereg_replace eregi eregi_replace split spliti join sql_regcase dl pclose popen readfile rewind rmdir umask fclose feof fgetc fgets fgetss fread fopen fpassthru ftruncate fstat fseek ftell fflush fwrite fputs mkdir rename copy tempnam tmpfile file file_get_contents file_put_contents stream_select stream_context_create stream_context_set_params stream_context_set_option stream_context_get_options stream_filter_prepend stream_filter_append fgetcsv flock get_meta_tags stream_set_write_buffer set_file_buffer set_socket_blocking stream_set_blocking socket_set_blocking stream_get_meta_data stream_register_wrapper stream_wrapper_register stream_set_timeout socket_set_timeout socket_get_status realpath fnmatch fsockopen pfsockopen pack unpack get_browser crypt opendir closedir chdir getcwd rewinddir readdir dir glob fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype file_exists is_writable is_writeable is_readable is_executable is_file is_dir is_link stat lstat chown touch clearstatcache mail ob_start ob_flush ob_clean ob_end_flush ob_end_clean ob_get_flush ob_get_clean ob_get_length ob_get_level ob_get_status ob_get_contents ob_implicit_flush ob_list_handlers ksort krsort natsort natcasesort asort arsort sort rsort usort uasort uksort shuffle array_walk count end prev next reset current key min max in_array array_search extract compact array_fill range array_multisort array_push array_pop array_shift array_unshift array_splice array_slice array_merge array_merge_recursive array_keys array_values array_count_values array_reverse array_reduce array_pad array_flip array_change_key_case array_rand array_unique array_intersect array_intersect_assoc array_diff array_diff_assoc array_sum array_filter array_map array_chunk array_key_exists array_intersect_key array_combine array_column pos sizeof key_exists assert assert_options version_compare ftok str_rot13 aggregate session_name session_module_name session_save_path session_id session_regenerate_id session_decode session_register session_unregister session_is_registered session_encode session_start session_destroy session_unset session_set_save_handler session_cache_limiter session_cache_expire session_set_cookie_params session_get_cookie_params session_write_close preg_match preg_match_all preg_replace preg_replace_callback preg_split preg_quote preg_grep overload ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_lower ctype_graph ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit virtual apache_request_headers apache_note apache_lookup_uri apache_child_terminate apache_setenv apache_response_headers apache_get_version getallheaders mysql_connect mysql_pconnect mysql_close mysql_select_db mysql_create_db mysql_drop_db mysql_query mysql_unbuffered_query mysql_db_query mysql_list_dbs mysql_list_tables mysql_list_fields mysql_list_processes mysql_error mysql_errno mysql_affected_rows mysql_insert_id mysql_result mysql_num_rows mysql_num_fields mysql_fetch_row mysql_fetch_array mysql_fetch_assoc mysql_fetch_object mysql_data_seek mysql_fetch_lengths mysql_fetch_field mysql_field_seek mysql_free_result mysql_field_name mysql_field_table mysql_field_len mysql_field_type mysql_field_flags mysql_escape_string mysql_real_escape_string mysql_stat mysql_thread_id mysql_client_encoding mysql_get_client_info mysql_get_host_info mysql_get_proto_info mysql_get_server_info mysql_info mysql mysql_fieldname mysql_fieldtable mysql_fieldlen mysql_fieldtype mysql_fieldflags mysql_selectdb mysql_createdb mysql_dropdb mysql_freeresult mysql_numfields mysql_numrows mysql_listdbs mysql_listtables mysql_listfields mysql_db_name mysql_dbname mysql_tablename mysql_table_name pg_connect pg_pconnect pg_close pg_connection_status pg_connection_busy pg_connection_reset pg_host pg_dbname pg_port pg_tty pg_options pg_ping pg_query pg_send_query pg_cancel_query pg_fetch_result pg_fetch_row pg_fetch_assoc pg_fetch_array pg_fetch_object pg_fetch_all pg_affected_rows pg_get_result pg_result_seek pg_result_status pg_free_result pg_last_oid pg_num_rows pg_num_fields pg_field_name pg_field_num pg_field_size pg_field_type pg_field_prtlen pg_field_is_null pg_get_notify pg_get_pid pg_result_error pg_last_error pg_last_notice pg_put_line pg_end_copy pg_copy_to pg_copy_from pg_trace pg_untrace pg_lo_create pg_lo_unlink pg_lo_open pg_lo_close pg_lo_read pg_lo_write pg_lo_read_all pg_lo_import pg_lo_export pg_lo_seek pg_lo_tell pg_escape_string pg_escape_bytea pg_unescape_bytea pg_client_encoding pg_set_client_encoding pg_meta_data pg_convert pg_insert pg_update pg_delete pg_select pg_exec pg_getlastoid pg_cmdtuples pg_errormessage pg_numrows pg_numfields pg_fieldname pg_fieldsize pg_fieldtype pg_fieldnum pg_fieldprtlen pg_fieldisnull pg_freeresult pg_result pg_loreadall pg_locreate pg_lounlink pg_loopen pg_loclose pg_loread pg_lowrite pg_loimport pg_loexport http_response_code get_declared_traits getimagesizefromstring socket_import_stream stream_set_chunk_size trait_exists header_register_callback class_uses session_status session_register_shutdown echo print global static exit array empty eval isset unset die include require include_once require_once json_decode json_encode json_last_error json_last_error_msg curl_close curl_copy_handle curl_errno curl_error curl_escape curl_exec curl_file_create curl_getinfo curl_init curl_multi_add_handle curl_multi_close curl_multi_exec curl_multi_getcontent curl_multi_info_read curl_multi_init curl_multi_remove_handle curl_multi_select curl_multi_setopt curl_multi_strerror curl_pause curl_reset curl_setopt_array curl_setopt curl_share_close curl_share_init curl_share_setopt curl_strerror curl_unescape curl_version mysqli_affected_rows mysqli_autocommit mysqli_change_user mysqli_character_set_name mysqli_close mysqli_commit mysqli_connect_errno mysqli_connect_error mysqli_connect mysqli_data_seek mysqli_debug mysqli_dump_debug_info mysqli_errno mysqli_error_list mysqli_error mysqli_fetch_all mysqli_fetch_array mysqli_fetch_assoc mysqli_fetch_field_direct mysqli_fetch_field mysqli_fetch_fields mysqli_fetch_lengths mysqli_fetch_object mysqli_fetch_row mysqli_field_count mysqli_field_seek mysqli_field_tell mysqli_free_result mysqli_get_charset mysqli_get_client_info mysqli_get_client_stats mysqli_get_client_version mysqli_get_connection_stats mysqli_get_host_info mysqli_get_proto_info mysqli_get_server_info mysqli_get_server_version mysqli_info mysqli_init mysqli_insert_id mysqli_kill mysqli_more_results mysqli_multi_query mysqli_next_result mysqli_num_fields mysqli_num_rows mysqli_options mysqli_ping mysqli_prepare mysqli_query mysqli_real_connect mysqli_real_escape_string mysqli_real_query mysqli_reap_async_query mysqli_refresh mysqli_rollback mysqli_select_db mysqli_set_charset mysqli_set_local_infile_default mysqli_set_local_infile_handler mysqli_sqlstate mysqli_ssl_set mysqli_stat mysqli_stmt_init mysqli_store_result mysqli_thread_id mysqli_thread_safe mysqli_use_result mysqli_warning_count\";\n  CodeMirror.registerHelper(\"hintWords\", \"php\", [phpKeywords, phpAtoms, phpBuiltin].join(\" \").split(\" \"));\n  CodeMirror.registerHelper(\"wordChars\", \"php\", /[\\w$]/);\n\n  var phpConfig = {\n    name: \"clike\",\n    helperType: \"php\",\n    keywords: keywords(phpKeywords),\n    blockKeywords: keywords(\"catch do else elseif for foreach if switch try while finally\"),\n    defKeywords: keywords(\"class function interface namespace trait\"),\n    atoms: keywords(phpAtoms),\n    builtin: keywords(phpBuiltin),\n    multiLineStrings: true,\n    hooks: {\n      \"$\": function(stream) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"variable-2\";\n      },\n      \"<\": function(stream, state) {\n        var before;\n        if (before = stream.match(/<<\\s*/)) {\n          var quoted = stream.eat(/['\"]/);\n          stream.eatWhile(/[\\w\\.]/);\n          var delim = stream.current().slice(before[0].length + (quoted ? 2 : 1));\n          if (quoted) stream.eat(quoted);\n          if (delim) {\n            (state.tokStack || (state.tokStack = [])).push(delim, 0);\n            state.tokenize = phpString(delim, quoted != \"'\");\n            return \"string\";\n          }\n        }\n        return false;\n      },\n      \"#\": function(stream) {\n        while (!stream.eol() && !stream.match(\"?>\", false)) stream.next();\n        return \"comment\";\n      },\n      \"/\": function(stream) {\n        if (stream.eat(\"/\")) {\n          while (!stream.eol() && !stream.match(\"?>\", false)) stream.next();\n          return \"comment\";\n        }\n        return false;\n      },\n      '\"': function(_stream, state) {\n        (state.tokStack || (state.tokStack = [])).push('\"', 0);\n        state.tokenize = phpString('\"');\n        return \"string\";\n      },\n      \"{\": function(_stream, state) {\n        if (state.tokStack && state.tokStack.length)\n          state.tokStack[state.tokStack.length - 1]++;\n        return false;\n      },\n      \"}\": function(_stream, state) {\n        if (state.tokStack && state.tokStack.length > 0 &&\n            !--state.tokStack[state.tokStack.length - 1]) {\n          state.tokenize = phpString(state.tokStack[state.tokStack.length - 2]);\n        }\n        return false;\n      }\n    }\n  };\n\n  CodeMirror.defineMode(\"php\", function(config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, (parserConfig && parserConfig.htmlMode) || \"text/html\");\n    var phpMode = CodeMirror.getMode(config, phpConfig);\n\n    function dispatch(stream, state) {\n      var isPHP = state.curMode == phpMode;\n      if (stream.sol() && state.pending && state.pending != '\"' && state.pending != \"'\") state.pending = null;\n      if (!isPHP) {\n        if (stream.match(/^<\\?\\w*/)) {\n          state.curMode = phpMode;\n          if (!state.php) state.php = CodeMirror.startState(phpMode, htmlMode.indent(state.html, \"\"))\n          state.curState = state.php;\n          return \"meta\";\n        }\n        if (state.pending == '\"' || state.pending == \"'\") {\n          while (!stream.eol() && stream.next() != state.pending) {}\n          var style = \"string\";\n        } else if (state.pending && stream.pos < state.pending.end) {\n          stream.pos = state.pending.end;\n          var style = state.pending.style;\n        } else {\n          var style = htmlMode.token(stream, state.curState);\n        }\n        if (state.pending) state.pending = null;\n        var cur = stream.current(), openPHP = cur.search(/<\\?/), m;\n        if (openPHP != -1) {\n          if (style == \"string\" && (m = cur.match(/[\\'\\\"]$/)) && !/\\?>/.test(cur)) state.pending = m[0];\n          else state.pending = {end: stream.pos, style: style};\n          stream.backUp(cur.length - openPHP);\n        }\n        return style;\n      } else if (isPHP && state.php.tokenize == null && stream.match(\"?>\")) {\n        state.curMode = htmlMode;\n        state.curState = state.html;\n        if (!state.php.context.prev) state.php = null;\n        return \"meta\";\n      } else {\n        return phpMode.token(stream, state.curState);\n      }\n    }\n\n    return {\n      startState: function() {\n        var html = CodeMirror.startState(htmlMode)\n        var php = parserConfig.startOpen ? CodeMirror.startState(phpMode) : null\n        return {html: html,\n                php: php,\n                curMode: parserConfig.startOpen ? phpMode : htmlMode,\n                curState: parserConfig.startOpen ? php : html,\n                pending: null};\n      },\n\n      copyState: function(state) {\n        var html = state.html, htmlNew = CodeMirror.copyState(htmlMode, html),\n            php = state.php, phpNew = php && CodeMirror.copyState(phpMode, php), cur;\n        if (state.curMode == htmlMode) cur = htmlNew;\n        else cur = phpNew;\n        return {html: htmlNew, php: phpNew, curMode: state.curMode, curState: cur,\n                pending: state.pending};\n      },\n\n      token: dispatch,\n\n      indent: function(state, textAfter) {\n        if ((state.curMode != phpMode && /^\\s*<\\//.test(textAfter)) ||\n            (state.curMode == phpMode && /^\\?>/.test(textAfter)))\n          return htmlMode.indent(state.html, textAfter);\n        return state.curMode.indent(state.curState, textAfter);\n      },\n\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\",\n\n      innerMode: function(state) { return {state: state.curState, mode: state.curMode}; }\n    };\n  }, \"htmlmixed\", \"clike\");\n\n  CodeMirror.defineMIME(\"application/x-httpd-php\", \"php\");\n  CodeMirror.defineMIME(\"application/x-httpd-php-open\", {name: \"php\", startOpen: true});\n  CodeMirror.defineMIME(\"text/x-php\", phpConfig);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/php/php.js\n// module id = 14\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                        \"for\", \"from\", \"global\", \"if\", \"import\",\n                        \"lambda\", \"pass\", \"raise\", \"return\",\n                        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                        \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function(conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]/;\n    //               (Backwards-compatiblity with old, cumbersome config system)\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n                     parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@])/]\n    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n\n    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined)\n      myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\n    if (parserConf.extra_builtins != undefined)\n      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3)\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                                      \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                                      \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins);\n\n    // tokenizers\n    function tokenBase(stream, state) {\n      if (stream.sol()) state.indent = stream.indentation()\n      // Handle scope changes\n      if (stream.sol() && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset)\n            pushPyScope(state);\n          else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n            state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state))\n            style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state) {\n      if (stream.eatSpace()) return null;\n\n      var ch = stream.peek();\n\n      // Handle Comments\n      if (ch == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Handle Number Literals\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n        if (stream.match(/^[\\d_]+\\.\\d*/)) { floatLiteral = true; }\n        if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n        // Binary\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n        // Octal\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n        // Decimal\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i);\n          // TODO - Can you have imaginary longs?\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      }\n\n      // Handle Strings\n      if (stream.match(stringPrefixes)) {\n        state.tokenize = tokenStringFactory(stream.current());\n        return state.tokenize(stream, state);\n      }\n\n      for (var i = 0; i < operators.length; i++)\n        if (stream.match(operators[i])) return \"operator\"\n\n      if (stream.match(delimiters)) return \"punctuation\";\n\n      if (state.lastToken == \".\" && stream.match(identifiers))\n        return \"property\";\n\n      if (stream.match(keywords) || stream.match(wordOperators))\n        return \"keyword\";\n\n      if (stream.match(builtins))\n        return \"builtin\";\n\n      if (stream.match(/^(self|cls)\\b/))\n        return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\")\n          return \"def\";\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function tokenStringFactory(delimiter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenBase;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenBase;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") state.scopes.pop()\n      state.scopes.push({offset: top(state).offset + conf.indentUnit,\n                         type: \"py\",\n                         align: null})\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^([\\s\\[\\{\\(]|#.*)*$/, false) ? null : stream.column() + 1\n      state.scopes.push({offset: state.indent + hangingIndent,\n                         type: type,\n                         align: align})\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) state.beginningOfLine = true;\n\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle decorators\n      if (state.beginningOfLine && current == \"@\")\n        return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n\n      if ((style == \"variable\" || style == \"builtin\")\n          && state.lastToken == \"meta\")\n        style = \"meta\";\n\n      // Handle scope changes.\n      if (current == \"pass\" || current == \"return\")\n        state.dedent += 1;\n\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\")\n        pushPyScope(state);\n\n      var delimiter_index = current.length == 1 ? \"[({\".indexOf(current) : -1;\n      if (delimiter_index != -1)\n        pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n      delimiter_index = \"])}\".indexOf(current);\n      if (delimiter_index != -1) {\n        if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent\n        else return ERRORCLASS;\n      }\n      if (state.dedent > 0 && stream.eol() && top(state).type == \"py\") {\n        if (state.scopes.length > 1) state.scopes.pop();\n        state.dedent -= 1;\n      }\n\n      return style;\n    }\n\n    var external = {\n      startState: function(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{offset: basecolumn || 0, type: \"py\", align: null}],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n\n      token: function(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n\n        if (style && style != \"comment\")\n          state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n\n        if (stream.eol() && state.lambda)\n          state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n\n      indent: function(state, textAfter) {\n        if (state.tokenize != tokenBase)\n          return state.tokenize.isString ? CodeMirror.Pass : 0;\n\n        var scope = top(state), closing = scope.type == textAfter.charAt(0)\n        if (scope.align != null)\n          return scope.align - (closing ? 1 : 0)\n        else\n          return scope.offset - (closing ? hangingIndent : 0)\n      },\n\n      electricInput: /^\\s*[\\}\\]\\)]$/,\n      closeBrackets: {triples: \"'\\\"\"},\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function(str) { return str.split(\" \"); };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \"+\n                          \"extern gil include nogil property public \"+\n                          \"readonly struct union DEF IF ELIF ELSE\")\n  });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/python/python.js\n// module id = 15\n// module chunks = 0","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"ruby\", function(config) {\n  function wordObj(words) {\n    var o = {};\n    for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;\n    return o;\n  }\n  var keywords = wordObj([\n    \"alias\", \"and\", \"BEGIN\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"defined?\", \"do\", \"else\",\n    \"elsif\", \"END\", \"end\", \"ensure\", \"false\", \"for\", \"if\", \"in\", \"module\", \"next\", \"not\", \"or\",\n    \"redo\", \"rescue\", \"retry\", \"return\", \"self\", \"super\", \"then\", \"true\", \"undef\", \"unless\",\n    \"until\", \"when\", \"while\", \"yield\", \"nil\", \"raise\", \"throw\", \"catch\", \"fail\", \"loop\", \"callcc\",\n    \"caller\", \"lambda\", \"proc\", \"public\", \"protected\", \"private\", \"require\", \"load\",\n    \"require_relative\", \"extend\", \"autoload\", \"__END__\", \"__FILE__\", \"__LINE__\", \"__dir__\"\n  ]);\n  var indentWords = wordObj([\"def\", \"class\", \"case\", \"for\", \"while\", \"until\", \"module\", \"then\",\n                             \"catch\", \"loop\", \"proc\", \"begin\"]);\n  var dedentWords = wordObj([\"end\", \"until\"]);\n  var matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\"};\n  var curPunc;\n\n  function chain(newtok, stream, state) {\n    state.tokenize.push(newtok);\n    return newtok(stream, state);\n  }\n\n  function tokenBase(stream, state) {\n    if (stream.sol() && stream.match(\"=begin\") && stream.eol()) {\n      state.tokenize.push(readBlockComment);\n      return \"comment\";\n    }\n    if (stream.eatSpace()) return null;\n    var ch = stream.next(), m;\n    if (ch == \"`\" || ch == \"'\" || ch == '\"') {\n      return chain(readQuoted(ch, \"string\", ch == '\"' || ch == \"`\"), stream, state);\n    } else if (ch == \"/\") {\n      if (regexpAhead(stream))\n        return chain(readQuoted(ch, \"string-2\", true), stream, state);\n      else\n        return \"operator\";\n    } else if (ch == \"%\") {\n      var style = \"string\", embed = true;\n      if (stream.eat(\"s\")) style = \"atom\";\n      else if (stream.eat(/[WQ]/)) style = \"string\";\n      else if (stream.eat(/[r]/)) style = \"string-2\";\n      else if (stream.eat(/[wxq]/)) { style = \"string\"; embed = false; }\n      var delim = stream.eat(/[^\\w\\s=]/);\n      if (!delim) return \"operator\";\n      if (matching.propertyIsEnumerable(delim)) delim = matching[delim];\n      return chain(readQuoted(delim, style, embed, true), stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    } else if (ch == \"<\" && (m = stream.match(/^<-?[\\`\\\"\\']?([a-zA-Z_?]\\w*)[\\`\\\"\\']?(?:;|$)/))) {\n      return chain(readHereDoc(m[1]), stream, state);\n    } else if (ch == \"0\") {\n      if (stream.eat(\"x\")) stream.eatWhile(/[\\da-fA-F]/);\n      else if (stream.eat(\"b\")) stream.eatWhile(/[01]/);\n      else stream.eatWhile(/[0-7]/);\n      return \"number\";\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+\\-]?[\\d_]+)?/);\n      return \"number\";\n    } else if (ch == \"?\") {\n      while (stream.match(/^\\\\[CM]-/)) {}\n      if (stream.eat(\"\\\\\")) stream.eatWhile(/\\w/);\n      else stream.next();\n      return \"string\";\n    } else if (ch == \":\") {\n      if (stream.eat(\"'\")) return chain(readQuoted(\"'\", \"atom\", false), stream, state);\n      if (stream.eat('\"')) return chain(readQuoted('\"', \"atom\", true), stream, state);\n\n      // :> :>> :< :<< are valid symbols\n      if (stream.eat(/[\\<\\>]/)) {\n        stream.eat(/[\\<\\>]/);\n        return \"atom\";\n      }\n\n      // :+ :- :/ :* :| :& :! are valid symbols\n      if (stream.eat(/[\\+\\-\\*\\/\\&\\|\\:\\!]/)) {\n        return \"atom\";\n      }\n\n      // Symbols can't start by a digit\n      if (stream.eat(/[a-zA-Z$@_\\xa1-\\uffff]/)) {\n        stream.eatWhile(/[\\w$\\xa1-\\uffff]/);\n        // Only one ? ! = is allowed and only as the last character\n        stream.eat(/[\\?\\!\\=]/);\n        return \"atom\";\n      }\n      return \"operator\";\n    } else if (ch == \"@\" && stream.match(/^@?[a-zA-Z_\\xa1-\\uffff]/)) {\n      stream.eat(\"@\");\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      return \"variable-2\";\n    } else if (ch == \"$\") {\n      if (stream.eat(/[a-zA-Z_]/)) {\n        stream.eatWhile(/[\\w]/);\n      } else if (stream.eat(/\\d/)) {\n        stream.eat(/\\d/);\n      } else {\n        stream.next(); // Must be a special global like $: or $!\n      }\n      return \"variable-3\";\n    } else if (/[a-zA-Z_\\xa1-\\uffff]/.test(ch)) {\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      stream.eat(/[\\?\\!]/);\n      if (stream.eat(\":\")) return \"atom\";\n      return \"ident\";\n    } else if (ch == \"|\" && (state.varList || state.lastTok == \"{\" || state.lastTok == \"do\")) {\n      curPunc = \"|\";\n      return null;\n    } else if (/[\\(\\)\\[\\]{}\\\\;]/.test(ch)) {\n      curPunc = ch;\n      return null;\n    } else if (ch == \"-\" && stream.eat(\">\")) {\n      return \"arrow\";\n    } else if (/[=+\\-\\/*:\\.^%<>~|]/.test(ch)) {\n      var more = stream.eatWhile(/[=+\\-\\/*:\\.^%<>~|]/);\n      if (ch == \".\" && !more) curPunc = \".\";\n      return \"operator\";\n    } else {\n      return null;\n    }\n  }\n\n  function regexpAhead(stream) {\n    var start = stream.pos, depth = 0, next, found = false, escaped = false\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (\"[{(\".indexOf(next) > -1) {\n          depth++\n        } else if (\"]})\".indexOf(next) > -1) {\n          depth--\n          if (depth < 0) break\n        } else if (next == \"/\" && depth == 0) {\n          found = true\n          break\n        }\n        escaped = next == \"\\\\\"\n      } else {\n        escaped = false\n      }\n    }\n    stream.backUp(stream.pos - start)\n    return found\n  }\n\n  function tokenBaseUntilBrace(depth) {\n    if (!depth) depth = 1;\n    return function(stream, state) {\n      if (stream.peek() == \"}\") {\n        if (depth == 1) {\n          state.tokenize.pop();\n          return state.tokenize[state.tokenize.length-1](stream, state);\n        } else {\n          state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);\n        }\n      } else if (stream.peek() == \"{\") {\n        state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);\n      }\n      return tokenBase(stream, state);\n    };\n  }\n  function tokenBaseOnce() {\n    var alreadyCalled = false;\n    return function(stream, state) {\n      if (alreadyCalled) {\n        state.tokenize.pop();\n        return state.tokenize[state.tokenize.length-1](stream, state);\n      }\n      alreadyCalled = true;\n      return tokenBase(stream, state);\n    };\n  }\n  function readQuoted(quote, style, embed, unescaped) {\n    return function(stream, state) {\n      var escaped = false, ch;\n\n      if (state.context.type === 'read-quoted-paused') {\n        state.context = state.context.prev;\n        stream.eat(\"}\");\n      }\n\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && (unescaped || !escaped)) {\n          state.tokenize.pop();\n          break;\n        }\n        if (embed && ch == \"#\" && !escaped) {\n          if (stream.eat(\"{\")) {\n            if (quote == \"}\") {\n              state.context = {prev: state.context, type: 'read-quoted-paused'};\n            }\n            state.tokenize.push(tokenBaseUntilBrace());\n            break;\n          } else if (/[@\\$]/.test(stream.peek())) {\n            state.tokenize.push(tokenBaseOnce());\n            break;\n          }\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      return style;\n    };\n  }\n  function readHereDoc(phrase) {\n    return function(stream, state) {\n      if (stream.match(phrase)) state.tokenize.pop();\n      else stream.skipToEnd();\n      return \"string\";\n    };\n  }\n  function readBlockComment(stream, state) {\n    if (stream.sol() && stream.match(\"=end\") && stream.eol())\n      state.tokenize.pop();\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: [tokenBase],\n              indented: 0,\n              context: {type: \"top\", indented: -config.indentUnit},\n              continuedLine: false,\n              lastTok: null,\n              varList: false};\n    },\n\n    token: function(stream, state) {\n      curPunc = null;\n      if (stream.sol()) state.indented = stream.indentation();\n      var style = state.tokenize[state.tokenize.length-1](stream, state), kwtype;\n      var thisTok = curPunc;\n      if (style == \"ident\") {\n        var word = stream.current();\n        style = state.lastTok == \".\" ? \"property\"\n          : keywords.propertyIsEnumerable(stream.current()) ? \"keyword\"\n          : /^[A-Z]/.test(word) ? \"tag\"\n          : (state.lastTok == \"def\" || state.lastTok == \"class\" || state.varList) ? \"def\"\n          : \"variable\";\n        if (style == \"keyword\") {\n          thisTok = word;\n          if (indentWords.propertyIsEnumerable(word)) kwtype = \"indent\";\n          else if (dedentWords.propertyIsEnumerable(word)) kwtype = \"dedent\";\n          else if ((word == \"if\" || word == \"unless\") && stream.column() == stream.indentation())\n            kwtype = \"indent\";\n          else if (word == \"do\" && state.context.indented < state.indented)\n            kwtype = \"indent\";\n        }\n      }\n      if (curPunc || (style && style != \"comment\")) state.lastTok = thisTok;\n      if (curPunc == \"|\") state.varList = !state.varList;\n\n      if (kwtype == \"indent\" || /[\\(\\[\\{]/.test(curPunc))\n        state.context = {prev: state.context, type: curPunc || style, indented: state.indented};\n      else if ((kwtype == \"dedent\" || /[\\)\\]\\}]/.test(curPunc)) && state.context.prev)\n        state.context = state.context.prev;\n\n      if (stream.eol())\n        state.continuedLine = (curPunc == \"\\\\\" || style == \"operator\");\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize[state.tokenize.length-1] != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0);\n      var ct = state.context;\n      var closing = ct.type == matching[firstChar] ||\n        ct.type == \"keyword\" && /^(?:end|until|else|elsif|when|rescue)\\b/.test(textAfter);\n      return ct.indented + (closing ? 0 : config.indentUnit) +\n        (state.continuedLine ? config.indentUnit : 0);\n    },\n\n    electricInput: /^\\s*(?:end|rescue|elsif|else|\\})$/,\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-ruby\", \"ruby\");\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/codemirror/mode/ruby/ruby.js\n// module id = 16\n// module chunks = 0"],"sourceRoot":""}